using System;
using System.Collections.Generic;

// TSUtil_CheckTimeSeries - check time series values.

/* NoticeStart

CDSS Common Java Library
CDSS Common Java Library is a part of Colorado's Decision Support Systems (CDSS)
Copyright (C) 1994-2019 Colorado Department of Natural Resources

CDSS Common Java Library is free software:  you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    CDSS Common Java Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with CDSS Common Java Library.  If not, see <https://www.gnu.org/licenses/>.

NoticeEnd */

namespace RTi.TS
{

	using Message = RTi.Util.Message.Message;
	using StringUtil = RTi.Util.String.StringUtil;
	using DataTable = RTi.Util.Table.DataTable;
	using TableField = RTi.Util.Table.TableField;
	using TableRecord = RTi.Util.Table.TableRecord;
	using DateTime = RTi.Util.Time.DateTime;
	using DateTimeWindow = RTi.Util.Time.DateTimeWindow;

	/// <summary>
	/// Check time series values.
	/// </summary>
	public class TSUtil_CheckTimeSeries
	{

	/// <summary>
	/// List of problems generated by this command, guaranteed to be non-null.
	/// </summary>
	private IList<string> __problems = new List<string>();

	/// <summary>
	/// Time series to process.
	/// </summary>
	private TS __ts = null;

	/// <summary>
	/// Type of check to perform.
	/// </summary>
	private CheckType __checkCriteria = null;

	/// <summary>
	/// Start of analysis (null to analyze all).
	/// </summary>
	private DateTime __analysisStart = null;

	/// <summary>
	/// End of analysis (null to analyze all).
	/// </summary>
	private DateTime __analysisEnd = null;

	/// <summary>
	/// Starting date/time for analysis window, within a year.
	/// </summary>
	private DateTime __analysisWindowStart = null;

	/// <summary>
	/// Ending date/time for analysis window, within a year.
	/// </summary>
	private DateTime __analysisWindowEnd = null;

	/// <summary>
	/// Value as input to analysis, depending on checkType.
	/// </summary>
	private double? __checkValue1 = null;

	/// <summary>
	/// Start of analysis (null to analyze all).
	/// </summary>
	private double? __checkValue2 = null;

	/// <summary>
	/// Problem type, flog problem logging (default is check type).
	/// </summary>
	private string __problemType = "";

	/// <summary>
	/// Number of checks that met the criteria.
	/// </summary>
	private int __checkCriteriaMetCount = 0;

	/// <summary>
	/// Flag string for detected values.
	/// </summary>
	private string __flag = null;

	/// <summary>
	/// Description for __flag.
	/// </summary>
	private string __flagDesc = null;

	/// <summary>
	/// Action to be performed on detection (either null/blank for no action, "Remove" to remove the data point,
	/// or "SetMissing" to set the data point to missing.  For regular, Remove and SetMissing are equivalent.
	/// </summary>
	private string __action = null;

	/// <summary>
	/// Table to receive checks.
	/// </summary>
	private DataTable __table = null;

	/// <summary>
	/// Name of table column for TSID.
	/// </summary>
	private string __tableTSIDColumn = null;

	/// <summary>
	/// Column number for __tableTSIDColumn.
	/// </summary>
	private int __tableTSIDColumnNum = 4;

	/// <summary>
	/// Name of table column for date/time.
	/// </summary>
	private string __tableDateTimeColumn = null;

	/// <summary>
	/// Column number for __tableDateTimeColumn.
	/// </summary>
	private int __tableDateTimeColumnNum = -1;

	/// <summary>
	/// Name of table column for time series value.
	/// </summary>
	private string __tableValueColumn = null;

	/// <summary>
	/// Precision of value column output.
	/// </summary>
	private int __tableValuePrecision = -1;

	/// <summary>
	/// Column number for __tableValueColumn.
	/// </summary>
	private int __tableValueColumnNum = -1;

	/// <summary>
	/// Name of table column for time series flag.
	/// </summary>
	private string __tableFlagColumn = null;

	/// <summary>
	/// Column number for __tableFlagColumn.
	/// </summary>
	private int __tableFlagColumnNum = -1;

	/// <summary>
	/// Name of table check type column for time series flag.
	/// </summary>
	private string __tableCheckTypeColumn = null;

	/// <summary>
	/// Column number for __tableCheckTypeColumn.
	/// </summary>
	private int __tableCheckTypeColumnNum = -1;

	/// <summary>
	/// Name of table check message column for time series flag.
	/// </summary>
	private string __tableCheckMessageColumn = null;

	/// <summary>
	/// Column number for __tableCheckMessageColumn.
	/// </summary>
	private int __tableCheckMessageColumnNum = -1;

	/// <summary>
	/// Format of TSID for table TSID column.
	/// </summary>
	private string __tableTSIDFormat = null;

	/// <summary>
	/// Constructor. </summary>
	/// <param name="ts"> time series to check </param>
	/// <param name="checkType"> the type of check to perform </param>
	/// <param name="analysisStart"> the start of the data period to check </param>
	/// <param name="analysisEnd"> the end of the data period to check </param>
	/// <param name="analysisWindowStart"> Starting date/time (year is ignored) for analysis within the year,
	/// in precision of the original data.  If null, the entire year of data will be analyzed. </param>
	/// <param name="analysisWindowEnd"> Ending date (year is ignored) for analysis within the year,
	/// in precision of the original data.  If null, the entire year of data will be analyzed. </param>
	/// <param name="checkValue1"> the first value to check against (depends on check type) </param>
	/// <param name="checkValue2"> the second value to check against (depends on check type) </param>
	/// <param name="problemType"> the string problem type to assign when data values match the check criteria (default is check criteria) </param>
	/// <param name="flag"> the data flag to assign to values that match the check criteria </param>
	/// <param name="flagDesc"> the description for the data flag (used in summary reports) </param>
	/// <param name="action"> the action to be taken for values that match the check criteria (in addition to flagging) - can
	/// be "SetMissing" to set the data value to missing, or "Remove" to remove the point (for irregular time series,
	/// equivalent to "SetMissing" for regular interval data) </param>
	/// <param name="table"> output DataTable - must have been created </param>
	/// <param name="tableTSIDColumn"> table column for TSID - will be added if not in the table </param>
	/// <param name="tableTSIDFormat"> format to format TSID for match in table, containing % specifiers and ${ts:property} </param>
	/// <param name="tableDateTimeColumn"> table column for date/time - will be added if not in the table </param>
	/// <param name="tableValueColumn"> table column for check values - will be added if not in the table </param>
	/// <param name="tableValuePrecision"> precision for tableValueColumn, or -1 to default </param>
	/// <param name="tableFlagColumn"> table column for time series flag corresponding to value - will be added if not in the table </param>
	/// <param name="tableCheckTypeColumn"> table column for check type - will be added if not in the table </param>
	/// <param name="tableCheckMessageColumn"> table column for check message - will be added if not in the table </param>
	public TSUtil_CheckTimeSeries(TS ts, CheckType checkType, DateTime analysisStart, DateTime analysisEnd, DateTime analysisWindowStart, DateTime analysisWindowEnd, double? checkValue1, double? checkValue2, string problemType, string flag, string flagDesc, string action, DataTable table, string tableTSIDColumn, string tableTSIDFormat, string tableDateTimeColumn, string tableValueColumn, int tableValuePrecision, string tableFlagColumn, string tableCheckTypeColumn, string tableCheckMessageColumn)
	{
		string message;
		string routine = this.GetType().Name;
		// Save data members.
		__ts = ts;
		__checkCriteria = checkType;
		__analysisStart = analysisStart;
		__analysisEnd = analysisEnd;
		__analysisWindowStart = analysisWindowStart;
		__analysisWindowEnd = analysisWindowEnd;
		__checkValue1 = checkValue1;
		__checkValue2 = checkValue2;
		if ((string.ReferenceEquals(problemType, null)) || problemType.Length == 0)
		{
			__problemType = "" + checkType;
		}
		__problemType = problemType;
		__flag = flag;
		__flagDesc = flagDesc;
		__action = action;
		__table = table;
		__tableTSIDColumn = tableTSIDColumn;
		__tableTSIDFormat = tableTSIDFormat;
		__tableDateTimeColumn = tableDateTimeColumn;
		__tableValueColumn = tableValueColumn;
		__tableValuePrecision = tableValuePrecision;
		__tableFlagColumn = tableFlagColumn;
		__tableCheckTypeColumn = tableCheckTypeColumn;
		__tableCheckMessageColumn = tableCheckMessageColumn;
		if ((!string.ReferenceEquals(__action, null)) && __action.Equals(""))
		{
			// Set to null for internal handling
			__action = null;
		}
		if ((!string.ReferenceEquals(action, null)) && !action.Equals("Remove", StringComparison.OrdinalIgnoreCase) && !action.Equals("SetMissing", StringComparison.OrdinalIgnoreCase))
		{
			message = "Action (" + action + ") is invalid.  Must be Remove or SetMissing if specified";
			Message.printWarning(3, routine, message);
			throw new InvalidParameterException(message);
		}
	}

	/// <summary>
	/// Check that the output table is set up.  The following columns are included:
	/// <ol>
	/// <li>TSID</li>
	/// <li>DateTime</li>
	/// <li>Value</li>
	/// <li>Flag</li>
	/// <li>CheckType</li>
	/// <li>CheckMessage</li>
	/// </ol> </summary>
	/// <param name="table"> table to set up </param>
	/// <param name="tableTSIDColumn"> name of column containing TSID </param>
	/// <param name="tableDateTimeColumn"> name of column containing date/time </param>
	/// <param name="tableValueColumn"> name of column containing value </param>
	/// <param name="tableValuePrecision"> precision of column containing value </param>
	/// <param name="tableFlagColumn"> name of column containing flag </param>
	/// <param name="tableCheckTypeColumn"> name of column containing check type </param>
	/// <param name="tableCheckMessageColumn"> name of column containing check message </param>
	/// <returns> true if table is being used, false if not. </returns>
	private bool checkTableSetup(DataTable table, string tableTSIDColumn, string tableDateTimeColumn, string tableValueColumn, int tableValuePrecision, string tableFlagColumn, string tableCheckTypeColumn, string tableCheckMessageColumn)
	{
		if (table == null)
		{
			return false;
		}
		try
		{
			if ((!string.ReferenceEquals(tableTSIDColumn, null)) && tableTSIDColumn.Length > 0)
			{
				__tableTSIDColumnNum = table.getFieldIndex(tableTSIDColumn);
			}
		}
		catch (Exception)
		{
			// Not found so create it
			__tableTSIDColumnNum = table.addField(0, new TableField(TableField.DATA_TYPE_STRING, tableTSIDColumn, -1, -1), "");
		}
		try
		{
			if ((!string.ReferenceEquals(tableDateTimeColumn, null)) && tableDateTimeColumn.Length > 0)
			{
				__tableDateTimeColumnNum = table.getFieldIndex(tableDateTimeColumn);
			}
		}
		catch (Exception)
		{
			// Not found so create it
			__tableDateTimeColumnNum = table.addField(1, new TableField(TableField.DATA_TYPE_DATETIME, tableDateTimeColumn, -1, -1), "");
		}
		try
		{
			if ((!string.ReferenceEquals(tableValueColumn, null)) && tableValueColumn.Length > 0)
			{
				__tableValueColumnNum = table.getFieldIndex(tableValueColumn);
			}
		}
		catch (Exception)
		{
			// Not found so create it - use 4 digits of precision for the check output
			__tableValueColumnNum = table.addField(2, new TableField(TableField.DATA_TYPE_DOUBLE, tableValueColumn, -1, tableValuePrecision), "");
		}
		try
		{
			if ((!string.ReferenceEquals(tableFlagColumn, null)) && tableFlagColumn.Length > 0)
			{
				__tableFlagColumnNum = table.getFieldIndex(tableFlagColumn);
			}
		}
		catch (Exception)
		{
			// Not found so create it
			__tableFlagColumnNum = table.addField(3,new TableField(TableField.DATA_TYPE_STRING, tableFlagColumn, -1, -1), "");
		}
		try
		{
			if ((!string.ReferenceEquals(tableCheckTypeColumn, null)) && tableCheckTypeColumn.Length > 0)
			{
				__tableCheckTypeColumnNum = table.getFieldIndex(tableCheckTypeColumn);
			}
		}
		catch (Exception)
		{
			// Not found so create it
			__tableCheckTypeColumnNum = table.addField(4,new TableField(TableField.DATA_TYPE_STRING, tableCheckTypeColumn, -1, -1), "");
		}
		try
		{
			if ((!string.ReferenceEquals(tableCheckMessageColumn, null)) && tableCheckMessageColumn.Length > 0)
			{
				__tableCheckMessageColumnNum = table.getFieldIndex(tableCheckMessageColumn);
			}
		}
		catch (Exception)
		{
			// Not found so create it
			__tableCheckMessageColumnNum = table.addField(5,new TableField(TableField.DATA_TYPE_STRING, tableCheckMessageColumn, -1, -1), "");
		}
		return true;
	}

	/// <summary>
	/// Check the time series.
	/// </summary>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: public void checkTimeSeries() throws Exception
	public virtual void checkTimeSeries()
	{ // Get class data for local processing
		DataTable table = __table;
		// Create a new list of problems
		__problems = new List<string>();
		int checkCriteriaMetCount = 0; // Number of values meeting the check criteria
		TS ts = getTimeSeries();
		CheckType checkCriteria = getCheckCriteria();
		string tsid = ts.getIdentifier().ToString();
		DateTime analysisWindowStart = getAnalysisWindowStart();
		DateTime analysisWindowEnd = getAnalysisWindowEnd();
		DateTimeWindow win = null;
		if ((analysisWindowStart != null) && (analysisWindowEnd != null))
		{
			win = new DateTimeWindow(analysisWindowStart,analysisWindowEnd);
		}

		// If time series has no data and check is for missing, add a message.
		// Otherwise skip
		if (!ts.hasData())
		{
			if (checkCriteria == CheckType.MISSING)
			{
				__problems.Add("Time series " + tsid + " has no data.");
			}
			return;
		}

		double value1 = (getCheckValue1() == null) ? -999.0 : getCheckValue1().Value;
		double value2 = (getCheckValue2() == null) ? -999.0 : getCheckValue2().Value;
		if ((!string.ReferenceEquals(ts.getAlias(), null)) && ts.getAlias().Length > 0)
		{
			tsid = ts.getAlias();
		}

		// If a table is being used for output, check that it has the required columns
		bool doTable = false;
		string tableTSID = ""; // Time series TSID formatted for table
		if (table != null)
		{
			doTable = checkTableSetup(table,__tableTSIDColumn,__tableDateTimeColumn, __tableValueColumn,__tableValuePrecision,__tableFlagColumn,__tableCheckTypeColumn, __tableCheckMessageColumn);
			tableTSID = ts.formatLegend(__tableTSIDFormat);
		}

		// Some statistics require "look forward processing" beyond checking the previous value.
		// Detect those here and process in a separate method

		if (checkCriteria == CheckType.REPEAT)
		{
			int value1Int = (int)(value1 + .01); // Ensure integer value given float parameter
			if (value1Int >= 2)
			{
				checkTimeSeriesLookForward(value1Int);
			}
			else if (value1Int < 2)
			{
				__problems.Add("For check criteria " + CheckType.REPEAT + ", Value1 must be >= 2.");
			}
			return;
		}

		// Iterate through the time series

		TSIterator tsi = ts.iterator(getAnalysisStart(), getAnalysisEnd());
		TSData data = null;
		double tsvalue; // time series data value
		double tsvaluePrev = 0; // time series data value (previous)
		string tsflag; // time series data flag
		int tsvalueCount = 0; // Number of values processed
		string message = null;
		DateTime date; // Date corresponding to data value
		bool isMissing;
		bool matchDetected; // whether a data value matched the check criteria - used to trigger action
		double diff;
		TSData dataPoint = new TSData(); // Used when setting the flag
		// TODO SAM 2010 evaluate whether to check units for precision
		string tsValueFormat = "%.6f"; // Format for values for messages
		while ((data = tsi.next()) != null)
		{
			// Analyze the value - do this brute force with string comparisons and improve performance once logic is in place
			message = null; // A non-null message indicates that the check criteria was met for the value
			date = tsi.getDate();
			// Check to see if the date is in the analysis window
			if ((win != null) && !win.isDateTimeInWindow(date))
			{
				continue;
			}
			matchDetected = false;
			tsvalue = data.getDataValue();
			tsflag = data.getDataFlag();
			isMissing = ts.isDataMissing(tsvalue);
			if (checkCriteria == CheckType.ABS_CHANGE_GREATER_THAN)
			{
				if ((tsvalueCount > 0) && !ts.isDataMissing(tsvaluePrev) && !isMissing)
				{
					diff = tsvalue - tsvaluePrev;
					if (Math.Abs(diff) > value1)
					{
						message = "Time series " + tsid + " value " + StringUtil.formatString(tsvalue,tsValueFormat) + " at " + date + " changed more than " + value1 + " since previous value " + StringUtil.formatString(tsvaluePrev,tsValueFormat) + " (diff=" + StringUtil.formatString(diff,tsValueFormat) + ")";
						matchDetected = true;
					}
				}
			}
			else if (checkCriteria == CheckType.ABS_CHANGE_PERCENT_GREATER_THAN)
			{
				if ((tsvalueCount > 0) && !ts.isDataMissing(tsvaluePrev) && !isMissing)
				{
					diff = ((tsvalue - tsvaluePrev) / tsvaluePrev) * 100.0;
					if (Math.Abs(diff) > value1)
					{
						message = "Time series " + tsid + " value " + StringUtil.formatString(tsvalue,tsValueFormat) +
							" at " + date + " changed more than " +
							value1 + "% since previous value " + StringUtil.formatString(tsvaluePrev,tsValueFormat) + " (diff %=" + StringUtil.formatString(diff,tsValueFormat) + ")";
						matchDetected = true;
					}
				}
			}
			else if (checkCriteria == CheckType.CHANGE_GREATER_THAN)
			{
				if ((tsvalueCount > 0) && !ts.isDataMissing(tsvaluePrev) && !isMissing)
				{
					diff = tsvalue - tsvaluePrev;
					if (diff > value1)
					{
						message = "Time series " + tsid + " value " + StringUtil.formatString(tsvalue,tsValueFormat) + " at " + date + " change is > " + value1 + " since previous value " + StringUtil.formatString(tsvaluePrev,tsValueFormat) + " (diff=" + StringUtil.formatString(diff,tsValueFormat) + ")";
						matchDetected = true;
					}
				}
			}
			else if (checkCriteria == CheckType.CHANGE_LESS_THAN)
			{
				if ((tsvalueCount > 0) && !ts.isDataMissing(tsvaluePrev) && !isMissing)
				{
					diff = tsvalue - tsvaluePrev;
					if (diff < value1)
					{
						message = "Time series " + tsid + " value " + StringUtil.formatString(tsvalue,tsValueFormat) + " at " + date + " change is < " + value1 + " since previous value " + StringUtil.formatString(tsvaluePrev,tsValueFormat) + " (diff=" + StringUtil.formatString(diff,tsValueFormat) + ")";
						matchDetected = true;
					}
				}
			}
			else if (checkCriteria == CheckType.EQUAL_TO)
			{
				if (!isMissing && (tsvalue == value1))
				{
					message = "Time series " + tsid + " value " + StringUtil.formatString(tsvalue,tsValueFormat) +
					" at " + date + " is = test value " + value1;
					matchDetected = true;
				}
			}
			else if (checkCriteria == CheckType.GREATER_THAN)
			{
				if (!isMissing && (tsvalue > value1))
				{
					message = "Time series " + tsid + " value " + StringUtil.formatString(tsvalue,tsValueFormat) +
					" at " + date + " is > limit " + value1;
					matchDetected = true;
				}
			}
			else if (checkCriteria == CheckType.GREATER_THAN_OR_EQUAL_TO)
			{
				if (!isMissing && (tsvalue >= value1))
				{
					message = "Time series " + tsid + " value " + StringUtil.formatString(tsvalue,tsValueFormat) +
					" at " + date + " is >= limit " + value1;
					matchDetected = true;
				}
			}
			else if (checkCriteria == CheckType.IN_RANGE)
			{
				if (!isMissing && (tsvalue >= value1) && (tsvalue <= value2))
				{
					message = "Time series " + tsid + " value " + StringUtil.formatString(tsvalue,tsValueFormat) +
					" at " + date + " is in range " + value1 + " to " + value2;
					matchDetected = true;
				}
			}
			else if (checkCriteria == CheckType.LESS_THAN)
			{
				if (!isMissing && (tsvalue < value1))
				{
					message = "Time series " + tsid + " value " + StringUtil.formatString(tsvalue,tsValueFormat) +
						" at " + date + " is < limit " + value1;
					matchDetected = true;
				}
			}
			else if (checkCriteria == CheckType.LESS_THAN_OR_EQUAL_TO)
			{
				if (!isMissing && (tsvalue <= value1))
				{
					message = "Time series " + tsid + " value " + StringUtil.formatString(tsvalue,tsValueFormat) +
					" at " + date + " is <= limit " + value1;
					matchDetected = true;
				}
			}
			else if (checkCriteria == CheckType.MISSING)
			{
				if (isMissing)
				{
					message = "Time series " + tsid + " value " + StringUtil.formatString(tsvalue,tsValueFormat) +
					" at " + date + " is missing";
					matchDetected = true;
				}
			}
			else if (checkCriteria == CheckType.OUT_OF_RANGE)
			{
				if (!isMissing && (tsvalue < value1) || (tsvalue > value2))
				{
					message = "Time series " + tsid + " value " + StringUtil.formatString(tsvalue,tsValueFormat) +
					" at " + date + " is out of range " + value1 + " to " + value2;
					matchDetected = true;
				}
			}
			else if (checkCriteria == CheckType.REPEAT)
			{
				if (!isMissing && (tsvalueCount > 0) && !ts.isDataMissing(tsvalue) && !ts.isDataMissing(tsvalue) && (tsvalue == tsvaluePrev))
				{
					message = "Time series " + tsid + " value " + StringUtil.formatString(tsvalue,tsValueFormat) +
					" at " + date + " repeated previous value";
					matchDetected = true;
				}
			}
			if (!string.ReferenceEquals(message, null))
			{
				// Add to the problems list
				__problems.Add(message);
				if (!string.ReferenceEquals(__flag, null))
				{
					// Update the flag value
					dataPoint = ts.getDataPoint(date, dataPoint);
					dataPoint.setDataFlag(__flag);
					ts.setDataValue(date, dataPoint.getDataValue(), dataPoint.getDataFlag(), dataPoint.getDuration());
					// Set the flag for use by the table
					tsflag = __flag;
				}
			}
			if (matchDetected && doTable)
			{
				// Save the results to the table
				// Add a record to the table
				TableRecord rec = table.emptyRecord();
				if (__tableTSIDColumnNum >= 0)
				{
					rec.setFieldValue(__tableTSIDColumnNum, tableTSID);
				}
				if (__tableDateTimeColumnNum >= 0)
				{
					// Make a copy since iterating
					rec.setFieldValue(__tableDateTimeColumnNum, new DateTime(date));
				}
				if (__tableValueColumnNum >= 0)
				{
					rec.setFieldValue(__tableValueColumnNum, tsvalue);
				}
				if (__tableFlagColumnNum >= 0)
				{
					rec.setFieldValue(__tableFlagColumnNum, tsflag);
				}
				if (__tableCheckTypeColumnNum >= 0)
				{
					rec.setFieldValue(__tableCheckTypeColumnNum, __problemType);
				}
				if (__tableCheckMessageColumnNum >= 0)
				{
					rec.setFieldValue(__tableCheckMessageColumnNum, message);
				}
				table.addRecord(rec);
			}
			// If an action is required, do it.
			if (matchDetected)
			{
				++checkCriteriaMetCount;
				if (!string.ReferenceEquals(__action, null))
				{
					if (__action.Equals("Remove", StringComparison.OrdinalIgnoreCase))
					{
						if (ts is IrregularTS)
						{
							// Remove the data point from memory
							((IrregularTS)ts).removeDataPoint(date);
						}
						else
						{
							// Set to missing
							ts.setDataValue(date, ts.getMissing());
						}
					}
					else if (__action.Equals("SetMissing", StringComparison.OrdinalIgnoreCase))
					{
						ts.setDataValue(date, ts.getMissing());
					}
				}
			}
			// Increment the count and save the previous value
			++tsvalueCount;
			tsvaluePrev = tsvalue;
		}
		if (checkCriteriaMetCount > 0)
		{
			this.__checkCriteriaMetCount = checkCriteriaMetCount;
			if ((!string.ReferenceEquals(__flag, null)) && __flag.Length > 0)
			{
				// Remove leading + on flag, used to indicate concatenation
				string flag = StringUtil.remove(__flag,"+");
				if ((string.ReferenceEquals(__flagDesc, null)) || __flagDesc.Equals(""))
				{
					// Default description...
					message = "Detected " + checkCriteriaMetCount + " values where " + formatCriteriaForFlagDesc() + ".";
					ts.addDataFlagMetadata(new TSDataFlagMetadata(flag, message));
				}
				else
				{
					// Use supplied description...
					message = "Detected " + checkCriteriaMetCount + " values where " + __flagDesc + ".";
					ts.addDataFlagMetadata(new TSDataFlagMetadata(flag, message));
				}
				// Add a message to the genesis since flags have been set...
				ts.addToGenesis(message + "  Set flag to " + __flag + ".");
			}
		}
	}

	/// <summary>
	/// Check the time series for checks that need to look forward, including:
	/// <ol>
	/// <li>Repeat</li>
	/// </ol>
	/// It is expected that primary checks are done in the checkTimeSeries() method.
	/// </summary>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: private void checkTimeSeriesLookForward(int value1) throws Exception
	private void checkTimeSeriesLookForward(int value1)
	{
		TS ts = getTimeSeries();
		CheckType checkCriteria = getCheckCriteria();
		string tsid = ts.getIdentifier().ToString();

		if ((!string.ReferenceEquals(ts.getAlias(), null)) && ts.getAlias().Length > 0)
		{
			tsid = ts.getAlias();
		}

		if (checkCriteria != CheckType.REPEAT)
		{
			__problems.Add("CheckTimeSeriesForward is only implemented for " + CheckType.REPEAT + ", logic problem.");
			return;
		}

		// Iterate through the time series

		TSIterator tsi = ts.iterator(getAnalysisStart(), getAnalysisEnd()); // Overall period
		TSIterator tsi2 = ts.iterator(getAnalysisStart(), getAnalysisEnd()); // Search forward window
		TSIterator tsi3 = ts.iterator(getAnalysisStart(), getAnalysisEnd()); // Action window
		TSData data = null; // Initial data point
		TSData data2 = null; // Data point looking forward
		double tsvalue; // time series data value
		double tsvalue2; // time series data value looking forward
		string message = null;
		DateTime date2; // Date corresponding to search forward
		DateTime startToAdjust; // Date corresponding to first offending value requiring adjustment
		DateTime endToAdjust; // Date corresponding to last offending value requiring adjustment
		TSData dataPoint = new TSData();
		// TODO SAM 2010 evaluate whether to check units for precision
		string tsValueFormat = "%.6f"; // Format for values for messages
		int countConditionMet = 0; // Number of times that forward values match condition
		int value1m1 = value1 - 1; // To simplify code
		while ((data = tsi.next()) != null)
		{
			// Time series value at the current interval
			tsvalue = data.getDataValue();
			//Message.printStatus(2, "", "Checking value " + tsvalue + " at " + data.getDate() + " for repeat." );
			// Skip over missing
			if (ts.isDataMissing(tsvalue))
			{
				continue;
			}
			// Look forward while values are the same.  Afterwards, deal with the sequence.
			date2 = data.getDate();
			tsi2.setBeginTime(date2);
			// Advance one so as to start comparison with value after...
			tsi2.next();
			countConditionMet = 0;
			startToAdjust = null;
			endToAdjust = null;
			while ((data2 = tsi2.next()) != null)
			{
				tsvalue2 = data2.getDataValue();
				if (tsvalue == tsvalue2)
				{
					++countConditionMet;
					if (countConditionMet >= value1m1)
					{
						// Save the first "offending" date/time that will need adjusting
						if (startToAdjust == null)
						{
							startToAdjust = new DateTime(data2.getDate());
						}
						// Also save the last "offending" date/time that will need adjusting
						endToAdjust = new DateTime(data2.getDate());
					}
				}
				else
				{
					// No more matching values - break and take necessary action below
					break;
				}
			}
			// Now evaluate the number of matching values...
			// A parameter of Value1=2 means that 2 repeating values triggers the response to the check,
			// for the 2nd+ values
			if (countConditionMet >= value1m1)
			{
				// Take action on the offending values and reset the main iterator to start after the adjusted
				// sequence
				// If an action is required, do it
				tsi3.setBeginTime(startToAdjust);
				tsi3.setEndTime(endToAdjust);
				int count = value1m1;
				while ((data2 = tsi3.next()) != null)
				{
					date2 = data2.getDate();
					tsvalue2 = data2.getDataValue();
					++count;
					message = "Time series " + tsid + " value " + StringUtil.formatString(tsvalue2,tsValueFormat) + " at " + date2 + " repeated (occurrence: " + count + ").";
					// Add to the problems list
					__problems.Add(message);
					if (!string.ReferenceEquals(__flag, null))
					{
						// Update the flag value
						dataPoint = ts.getDataPoint(date2, dataPoint);
						dataPoint.setDataFlag(__flag);
						ts.setDataValue(date2, dataPoint.getDataValue(), dataPoint.getDataFlag(), dataPoint.getDuration());
					}
					if (!string.ReferenceEquals(__action, null))
					{
						if (__action.Equals("Remove", StringComparison.OrdinalIgnoreCase))
						{
							if (ts is IrregularTS)
							{
								// Remove the data point from memory
								((IrregularTS)ts).removeDataPoint(date2);
							}
							else
							{
								// Set to missing
								ts.setDataValue(date2, ts.getMissing());
							}
						}
						else if (__action.Equals("SetMissing", StringComparison.OrdinalIgnoreCase))
						{
							ts.setDataValue(date2, ts.getMissing());
						}
					}
				}
				// Advance the main iterator to start checking the next value after the sequence
				tsi.setBeginTime(endToAdjust);
				tsi.next(); // Will return the new begin time
			}
			else
			{
				// No conditions met.  No action taken.
				// Just advance the iterator and check the next sequence.
			}
		}
		// Final data annotations based on full count of matches.
		if ((!string.ReferenceEquals(__flag, null)) && !__flag.Equals("") && (__problems.Count > 0))
		{
			// Remove leading + on flag, used to indicate concatenation
			string flag = StringUtil.remove(__flag,"+");
			if ((string.ReferenceEquals(__flagDesc, null)) || __flagDesc.Equals(""))
			{
				// Default description...
				message = "Detected " + __problems.Count + " values where " + formatCriteriaForFlagDesc() + ".";
				ts.addDataFlagMetadata(new TSDataFlagMetadata(flag, message));
			}
			else
			{
				// Use supplied description...
				message = "Detected " + __problems.Count + " values where " + __flagDesc + ".";
				ts.addDataFlagMetadata(new TSDataFlagMetadata(flag, message));
			}
			// Add a message to the genesis since flags have been set...
			ts.addToGenesis(message + "  Set flag to " + __flag + ".");
		}
	}

	/// <summary>
	/// Format the criteria for use in output. </summary>
	/// <returns> a string that describes the criteria, suitable for the flag description. </returns>
	private string formatCriteriaForFlagDesc()
	{
		if (__checkCriteria == CheckType.ABS_CHANGE_GREATER_THAN)
		{
			return "abs(change(value)) > " + StringUtil.formatString(__checkValue1,"%.6f");
		}
		else if (__checkCriteria == CheckType.ABS_CHANGE_PERCENT_GREATER_THAN)
		{
			return "percent(abs(change(value))) > " + StringUtil.formatString(__checkValue1,"%.6f");
		}
		else if (__checkCriteria == CheckType.CHANGE_GREATER_THAN)
		{
			return "change(value) > " + StringUtil.formatString(__checkValue1,"%.6f");
		}
		else if (__checkCriteria == CheckType.CHANGE_LESS_THAN)
		{
			return "change(value) < " + StringUtil.formatString(__checkValue1,"%.6f");
		}
		else if (__checkCriteria == CheckType.IN_RANGE)
		{
			return StringUtil.formatString(__checkValue1,"%.6f") + " <= value <= " + StringUtil.formatString(__checkValue2,"%.6f");
		}
		else if (__checkCriteria == CheckType.OUT_OF_RANGE)
		{
			return "value < " + StringUtil.formatString(__checkValue1,"%.6f") + " OR value > " + StringUtil.formatString(__checkValue2,"%.6f");
		}
		else if (__checkCriteria == CheckType.MISSING)
		{
			return "value is missing";
		}
		else if (__checkCriteria == CheckType.REPEAT)
		{
			return "value repeats previous value";
		}
		else if (__checkCriteria == CheckType.LESS_THAN)
		{
			return "value < " + StringUtil.formatString(__checkValue1,"%.6f");
		}
		else if (__checkCriteria == CheckType.LESS_THAN_OR_EQUAL_TO)
		{
			return "value <= " + StringUtil.formatString(__checkValue1,"%.6f");
		}
		else if (__checkCriteria == CheckType.GREATER_THAN)
		{
			return "value > " + StringUtil.formatString(__checkValue1,"%.6f");
		}
		else if (__checkCriteria == CheckType.GREATER_THAN_OR_EQUAL_TO)
		{
			return "value >= " + StringUtil.formatString(__checkValue1,"%.6f");
		}
		else if (__checkCriteria == CheckType.EQUAL_TO)
		{
			return "value = " + StringUtil.formatString(__checkValue1,"%.6f");
		}
		else
		{
			throw new InvalidParameterException("Unrecognized check criteria \"" + __checkCriteria + "\"");
		}
	}

	/// <summary>
	/// Return the analysis end date/time. </summary>
	/// <returns> the analysis end date/time. </returns>
	public virtual DateTime getAnalysisEnd()
	{
		return __analysisEnd;
	}

	/// <summary>
	/// Return the analysis start date/time. </summary>
	/// <returns> the analysis start date/time. </returns>
	public virtual DateTime getAnalysisStart()
	{
		return __analysisStart;
	}

	/// <summary>
	/// Return the analysis window end date/time. </summary>
	/// <returns> the analysis window end date/time. </returns>
	public virtual DateTime getAnalysisWindowEnd()
	{
		return __analysisWindowEnd;
	}

	/// <summary>
	/// Return the analysis window start date/time. </summary>
	/// <returns> the analysis window start date/time. </returns>
	public virtual DateTime getAnalysisWindowStart()
	{
		return __analysisWindowStart;
	}

	/// <summary>
	/// Return the check type. </summary>
	/// <returns> the check type. </returns>
	public virtual CheckType getCheckCriteria()
	{
		return __checkCriteria;
	}

	/// <summary>
	/// Get the list of check types that can be performed.
	/// </summary>
	public static IList<CheckType> getCheckCriteriaChoices()
	{
		IList<CheckType> choices = new List<CheckType>();
		choices.Add(CheckType.ABS_CHANGE_GREATER_THAN);
		choices.Add(CheckType.ABS_CHANGE_PERCENT_GREATER_THAN);
		choices.Add(CheckType.CHANGE_GREATER_THAN);
		choices.Add(CheckType.CHANGE_LESS_THAN);
		choices.Add(CheckType.IN_RANGE);
		choices.Add(CheckType.OUT_OF_RANGE);
		choices.Add(CheckType.MISSING);
		choices.Add(CheckType.REPEAT);
		choices.Add(CheckType.LESS_THAN);
		choices.Add(CheckType.LESS_THAN_OR_EQUAL_TO);
		choices.Add(CheckType.GREATER_THAN);
		choices.Add(CheckType.GREATER_THAN_OR_EQUAL_TO);
		choices.Add(CheckType.EQUAL_TO);
		return choices;
	}

	/// <summary>
	/// Get the list of statistics that can be performed. </summary>
	/// <returns> the statistic display names as strings. </returns>
	public static IList<string> getCheckCriteriaChoicesAsStrings()
	{
		IList<CheckType> choices = getCheckCriteriaChoices();
		IList<string> stringChoices = new List<string>();
		for (int i = 0; i < choices.Count; i++)
		{
			stringChoices.Add("" + choices[i]);
		}
		return stringChoices;
	}

	/// <summary>
	/// Return the number of values where the check criteria was met.
	/// </summary>
	public virtual int getCheckCriteriaMetCount()
	{
		return __checkCriteriaMetCount;
	}

	/// <summary>
	/// Return the number of values that are required to evaluate a criteria. </summary>
	/// <returns> the number of values that are required to evaluate a criteria. </returns>
	/// <param name="checkCriteria"> the check criteria that is being evaluated. </param>
	public static int getRequiredNumberOfValuesForCheckCriteria(CheckType checkCriteria)
	{
		// TODO SAM 2009-04-23 Need to convert to enumeration or something other than simple strings
		if (checkCriteria == CheckType.ABS_CHANGE_PERCENT_GREATER_THAN)
		{
			return 1;
		}
		else if (checkCriteria == CheckType.ABS_CHANGE_GREATER_THAN)
		{
			return 1;
		}
		else if (checkCriteria == CheckType.CHANGE_GREATER_THAN)
		{
			return 1;
		}
		else if (checkCriteria == CheckType.CHANGE_LESS_THAN)
		{
			return 1;
		}
		else if (checkCriteria == CheckType.EQUAL_TO)
		{
			return 1;
		}
		else if (checkCriteria == CheckType.GREATER_THAN)
		{
			return 1;
		}
		else if (checkCriteria == CheckType.GREATER_THAN_OR_EQUAL_TO)
		{
			return 1;
		}
		else if (checkCriteria == CheckType.IN_RANGE)
		{
			return 2;
		}
		else if (checkCriteria == CheckType.LESS_THAN)
		{
			return 1;
		}
		else if (checkCriteria == CheckType.LESS_THAN_OR_EQUAL_TO)
		{
			return 1;
		}
		else if (checkCriteria == CheckType.MISSING)
		{
			return 0;
		}
		else if (checkCriteria == CheckType.OUT_OF_RANGE)
		{
			return 2;
		}
		else if (checkCriteria == CheckType.REPEAT)
		{
			return 1;
		}
		else
		{
			string message = "Requested criteria is not recognized: " + checkCriteria;
			string routine = "TSUtil_CheckTimeSeries.getRequiredNumberOfValuesForCheckCriteria";
			Message.printWarning(3, routine, message);
			throw new InvalidParameterException(message);
		}
	}

	/// <summary>
	/// Return a list of problems for the time series.
	/// </summary>
	public virtual IList<string> getProblems()
	{
		return __problems;
	}

	/// <summary>
	/// Return the time series being analyzed. </summary>
	/// <returns> the time series being analyzed. </returns>
	public virtual TS getTimeSeries()
	{
		return __ts;
	}

	/// <summary>
	/// Return the first check constraint value. </summary>
	/// <returns> the first check constraint value </returns>
	public virtual double? getCheckValue1()
	{
		return __checkValue1;
	}

	/// <summary>
	/// Return the second check constraint value </summary>
	/// <returns> the second check constraint value </returns>
	public virtual double? getCheckValue2()
	{
		return __checkValue2;
	}

	}

}