using System;
using System.Text;

// AbstractCommand - this class can be used as a parent class for other commands.

/* NoticeStart

CDSS Common Java Library
CDSS Common Java Library is a part of Colorado's Decision Support Systems (CDSS)
Copyright (C) 1994-2019 Colorado Department of Natural Resources

CDSS Common Java Library is free software:  you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    CDSS Common Java Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with CDSS Common Java Library.  If not, see <https://www.gnu.org/licenses/>.

NoticeEnd */

namespace RTi.Util.IO
{

	using Message = RTi.Util.Message.Message;

	/// <summary>
	/// This class can be used as a parent class for other commands.  It contains data
	/// members and access methods that commonly are used and do not need to be implemented in specific command classes.
	/// Note that the derived class should implement the Command interface methods - its
	/// implementation here will be insufficient for most needs (e.g., editing).
	/// </summary>
	public abstract class AbstractCommand : object, Command, CommandStatusProvider, CommandProcessorEventProvider
	{

	/// <summary>
	/// The full command string for the command, as specified during initialization.
	/// This is initialized to blank.
	/// </summary>
	private string __commandString = "";

	/// <summary>
	/// The command name only, as taken from the command string.
	/// This is initialized to blank;
	/// </summary>
	private string __commandName = "";

	/// <summary>
	/// The command processor, which will run the command and be associated with the command GUI.
	/// </summary>
	private CommandProcessor __processor = null;

	/// <summary>
	/// Array of CommandProcessorEventListeners.
	/// </summary>
	private CommandProcessorEventListener[] __CommandProcessorEventListener_array = null;

	/// <summary>
	/// Array of CommandProgressListeners.
	/// </summary>
	private CommandProgressListener[] __CommandProgressListener_array = null;

	/// <summary>
	/// The command parameters, determined from processing the command string.
	/// This is initialized to an empty PropList and should be set when initializing the command.
	/// </summary>
	private PropList __parameters = new PropList("");

	/// <summary>
	/// The status for the command.
	/// </summary>
	private CommandStatus __status = new CommandStatus();

	/// <summary>
	/// Whether or not the command is a plugin.
	/// </summary>
	private bool __isPlugin = false;

	// TODO SAM 2016-03-23 Evaluate whether command profile should be null and only instantiated baesd
	// on a processor property, in order to save memory.
	/// <summary>
	/// The runtime profile for the command.  Although designed to have a profile for each command phase,
	/// focus on the run phase for now.
	/// </summary>
	private CommandProfile __profile = new CommandProfile();

	/// <summary>
	/// Default constructor for a command.
	/// </summary>
	public AbstractCommand()
	{
	}

	/// <summary>
	/// Add a CommandProcessorEventListener. </summary>
	/// <param name="listener"> a CommandProcessorEventListener, to handle events generated by this command. </param>
	public virtual void addCommandProcessorEventListener(CommandProcessorEventListener listener)
	{
		// Use arrays to make a little simpler than Vectors to use later...
		if (listener == null)
		{
			return;
		}
		// See if the listener has already been added...
		// Resize the listener array...
		int size = 0;
		if (__CommandProcessorEventListener_array != null)
		{
			size = __CommandProcessorEventListener_array.Length;
		}
		for (int i = 0; i < size; i++)
		{
			if (__CommandProcessorEventListener_array[i] == listener)
			{
				return;
			}
		}
		if (__CommandProcessorEventListener_array == null)
		{
			__CommandProcessorEventListener_array = new CommandProcessorEventListener[1];
			__CommandProcessorEventListener_array[0] = listener;
		}
		else
		{
			// Need to resize and transfer the list...
			size = __CommandProcessorEventListener_array.Length;
			CommandProcessorEventListener[] newlisteners = new CommandProcessorEventListener[size + 1];
			for (int i = 0; i < size; i++)
			{
					newlisteners[i] = __CommandProcessorEventListener_array[i];
			}
			__CommandProcessorEventListener_array = newlisteners;
			__CommandProcessorEventListener_array[size] = listener;
			newlisteners = null;
		}
	}

	/// <summary>
	/// Add a CommandProgressListener. </summary>
	/// <param name="listener"> a CommandProgressListener, to handle events generated by this command. </param>
	public virtual void addCommandProgressListener(CommandProgressListener listener)
	{
		// Use arrays to make a little simpler than lists to use later...
		if (listener == null)
		{
			return;
		}
		// See if the listener has already been added...
		// Resize the listener array...
		int size = 0;
		if (__CommandProgressListener_array != null)
		{
			size = __CommandProgressListener_array.Length;
		}
		for (int i = 0; i < size; i++)
		{
			if (__CommandProgressListener_array[i] == listener)
			{
				return;
			}
		}
		if (__CommandProgressListener_array == null)
		{
			__CommandProgressListener_array = new CommandProgressListener[1];
			__CommandProgressListener_array[0] = listener;
		}
		else
		{
			// Need to resize and transfer the list...
			size = __CommandProgressListener_array.Length;
			CommandProgressListener[] newlisteners = new CommandProgressListener[size + 1];
			for (int i = 0; i < size; i++)
			{
				newlisteners[i] = __CommandProgressListener_array[i];
			}
			__CommandProgressListener_array = newlisteners;
			__CommandProgressListener_array[size] = listener;
			newlisteners = null;
		}
	}

	/// <summary>
	/// Check the command parameter for valid values, combination, etc.
	/// This should normally be implemented in the derived class. </summary>
	/// <param name="parameters"> The parameters for the command. </param>
	/// <param name="command_tag"> an indicator to be used when printing messages, to allow a
	/// cross-reference to the original commands. </param>
	/// <param name="warning_level"> The warning level to use when printing parse warnings
	/// (recommended is 2 for initialization, and 1 for interactive command editor dialogs). </param>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: public void checkCommandParameters(PropList parameters, String command_tag, int warning_level) throws InvalidCommandParameterException
	public virtual void checkCommandParameters(PropList parameters, string command_tag, int warning_level)
	{
	}

	/// <summary>
	/// Clone the instance.  All command data are cloned except for, the following,
	/// which use the same references as the original object:  CommandProcessor.
	/// </summary>
	public virtual object clone()
	{
		try
		{
			AbstractCommand command = (AbstractCommand)base.clone();
			// _command_string and _command_name are automatically cloned
			// Processor is not cloned, use a reference to the same processor
			command.__processor = __processor;
			// Clone the status...
			command.__status = (CommandStatus)__status.clone();
			// Clone the parameters - do this the brute force way for now using
			// string properties but later need to evaluate, especially if
			// full objects are used for parameters...
			// TODO SAM 2007-09-02 Need full clone() on PropList
			PropList props = new PropList("");
			int size = command.__parameters.size();
			Prop prop = null;
			for (int i = 0; i < size; i++)
			{
				prop = command.__parameters.elementAt(i);
				if (prop == null)
				{
					// Should not happen.
				}
				else
				{
					props.set(prop.getKey(), prop.getValue());
				}
			}
			command.__parameters = props;
			return command;
		}
		catch (CloneNotSupportedException)
		{
			// Should not happen because everything is cloneable.
			throw new InternalError();
		}
	}

	/// <summary>
	/// Edit a command instance.  The instance may be a newly created command or one
	/// that has been created previously and is now being re-edited. </summary>
	/// <returns> the Command instance that is created and edited, or null if the edit was canceled. </returns>
	/// <param name="parent"> Parent JFrame on which the model command editor dialog will be shown. </param>
	public virtual bool editCommand(JFrame parent)
	{ // Use the generic command editor...
		return (new GenericCommand_JDialog(parent, this)).ok();
	}

	/// <summary>
	/// Edit a new command. </summary>
	/// <returns> the Command instance that is created and edited, or null if the edit was canceled. </returns>
	/// <param name="parent"> Parent JFrame on which the model command editor dialog will be shown. </param>
	/* TODO SAM 2005-04-29 need to figure out a graceful way to do this...
	CommandFactory?
	public static Command editNewCommand ( JFrame parent )
	{	Command c = new Command();
		if ( c.editCommand(parent).ok() ) {
			return c;
		}
		else {	return null;
		}
	}
	*/

	/// <summary>
	/// Return the command name, from the command string. </summary>
	/// <returns> the command name, from the command string. </returns>
	public virtual string getCommandName()
	{
		return __commandName;
	}

	/// <summary>
	/// Return the parameters being used by the command.  The Prop.getHowSet() method
	/// can be used to determine whether a property was defined in the original command
	/// string (Prop.SET_FROM_PERSISTENT) or is defaulted internally
	/// (Prop.SET_AS_RUNTIME_DEFAULT).
	/// TODO SAM 2005-04-29 Does this need a boolean parameter to allow dialogs to
	/// see only the parameters in the command, so that defaults are not explicitly displayed? </summary>
	/// <returns> the parameters being used by the command.  A non-null list is guaranteed. </returns>
	public virtual PropList getCommandParameters()
	{
		return __parameters;
	}

	/// <summary>
	/// Return the command processor that is managing the command. </summary>
	/// <returns> the CommandProcessor used to process the command. </returns>
	public virtual CommandProcessor getCommandProcessor()
	{
		return __processor;
	}

	/// <summary>
	/// Return the command profile for the requested phase.  Currently a profile is only implemented for
	/// the run phase. </summary>
	/// <param name="phase"> the command phase (currently only CommandPhaseType.RUN is supported) </param>
	/// <returns> the command profile (null if other than CommandPhaseType.RUN is requested) </returns>
	public virtual CommandProfile getCommandProfile(CommandPhaseType phase)
	{
		if (phase == CommandPhaseType.RUN)
		{
			return __profile;
		}
		return null;
	}

	/// <summary>
	/// Return the status for the command.  The version provided in this abstract
	/// version returns UNKNOWN for the status.  Commands that extend from this abstract
	/// class should set the status more explicitly.
	/// </summary>
	public virtual CommandStatus getCommandStatus()
	{
		return __status;
	}

	/// <summary>
	/// Returns the original command string. </summary>
	/// <returns> the original command string. </returns>
	public virtual string getCommandString()
	{
		return __commandString;
	}

	/// <summary>
	/// Indicate whether the command is a plugin command.
	/// This will result in different handling of command data.
	/// </summary>
	public virtual bool getIsCommandPlugin()
	{
		return this.__isPlugin;
	}

	/// <summary>
	/// Initialize the command by parsing the command and indicating warnings. </summary>
	/// <param name="command"> A string command to parse.  This is necessary because the
	/// command factory typically only uses a command string to instantiate the proper
	/// Command class, but parameters are not parsed until this method is called. </param>
	/// <param name="full_initialization"> If true, the command string will be parsed and
	/// checked for errors (by calling parseCommand()).  If false, a blank command will
	/// be initialized (e.g., suitable for creating a new command instance before
	/// editing in the command editor). </param>
	/// <exception cref="InvalidCommandSyntaxException"> if during parsing the command is
	/// determined to have invalid syntax. </exception>
	/// <exception cref="InvalidCommandParameterException"> if during parsing the command
	/// parameters are determined to be invalid. </exception>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: public void initializeCommand(String command, CommandProcessor processor, boolean full_initialization) throws InvalidCommandSyntaxException, InvalidCommandParameterException
	public virtual void initializeCommand(string command, CommandProcessor processor, bool full_initialization)
	{ // Save the processor...
		__processor = processor;
		__commandString = command;
		if (full_initialization)
		{
			// Parse the command...
			parseCommand(command);
		}
	}

	// TODO SAM 2005-05-13 Might need to overload this to pass the routine
	// from the derived class, and then rely on the standard method.

	/// <summary>
	/// Notify registered CommandProcessorEventListeners of a CommandProcessorEvent. </summary>
	/// <param name="event"> event to pass to listeners. </param>
	public virtual void notifyCommandProcessorEventListeners(CommandProcessorEvent @event)
	{
		if (__CommandProcessorEventListener_array != null)
		{
			for (int i = 0; i < __CommandProcessorEventListener_array.Length; i++)
			{
				__CommandProcessorEventListener_array[i].handleCommandProcessorEvent(@event);
			}
		}
	}

	/// <summary>
	/// Notify registered CommandProgressListeners of a CommandProgressEvent. </summary>
	/// <param name="istep"> The number of steps being executed in a command (0+), for example loop index of
	/// objects being processed. </param>
	/// <param name="nstep"> The total number of steps to process within a command, for example total number of objects
	/// being processed. </param>
	/// <param name="percentComplete"> If >= 0, the value can be used to indicate progress
	/// running a single command.  If less than zero, then
	/// no estimate is given for the percent complete and calling code can make its
	/// own determination (e.g., ((istep + 1)/nstep)*100). </param>
	/// <param name="message"> A short message describing the status (e.g., "Running command ..." ). </param>
	public virtual void notifyCommandProgressListeners(int istep, int nstep, float percentComplete, string message)
	{
		if (__CommandProgressListener_array != null)
		{
			for (int i = 0; i < __CommandProgressListener_array.Length; i++)
			{
				__CommandProgressListener_array[i].commandProgress(istep, nstep, this, percentComplete, message);
			}
		}
	}

	/// <summary>
	/// Parse the command string into a PropList of parameters.  This method will parse a standard syntax command:
	/// <pre>
	/// commandName(param=value,param="value",param="value(xxx)",...)
	/// </pre>
	/// Custom parsers MUST be implemented for special commands, such as comments and legacy syntax.
	/// Parameter values can contain special characters such as parenthesis but should generally be quoted in these cases. </summary>
	/// <param name="command"> A string command to parse. </param>
	/// <exception cref="InvalidCommandSyntaxException"> if during parsing the command is
	/// determined to have invalid syntax. </exception>
	/// <exception cref="InvalidCommandParameterException"> if during parsing the command
	/// parameters are determined to be invalid. </exception>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: public void parseCommand(String command) throws InvalidCommandSyntaxException, InvalidCommandParameterException
	public virtual void parseCommand(string command)
	{
		string routine = "SkeletonCommand.parseCommand", message;
		// The following causes problems with commands that have quoted parameters that include ()
		// Therefore, parse more brute force to get the command name and parameter list string
		// List<String> tokens = StringUtil.breakStringList ( command, "()", StringUtil.DELIM_SKIP_BLANKS );
		string commandTrimmed = command.Trim();
		int parenStart = commandTrimmed.IndexOf("(", StringComparison.Ordinal);
		int parenEnd = commandTrimmed.LastIndexOf(")", StringComparison.Ordinal);
		if ((parenStart <= 0) || (parenEnd != (commandTrimmed.Length - 1)))
		{
			message = "Invalid syntax for \"" + command + "\".  Expecting CommandName(parameter=value,...)";
			Message.printWarning(2, routine, message);
			throw new InvalidCommandSyntaxException(message);
		}
		if (parenEnd != (commandTrimmed.Length - 1))
		{
			message = "Invalid syntax for \"" + commandTrimmed + "\".  Expecting CommandName(parameter=value,...)";
			Message.printWarning(2, routine, message);
			throw new InvalidCommandSyntaxException(message);
		}
		// Get the parameter list...
		string parameterString = commandTrimmed.Substring((parenStart + 1), parenEnd - (parenStart + 1));
		if (parameterString.Length > 0)
		{
			// Parameters are available to parse...
			try
			{
				__parameters = PropList.parse(Prop.SET_FROM_PERSISTENT, parameterString, routine,",");
			}
			catch (Exception)
			{
				message = "Syntax error in \"" + commandTrimmed + "\".  Not enough tokens.";
				Message.printWarning(2, routine, message);
				throw new InvalidCommandSyntaxException(message);
			}
		}
	}

	/// <summary>
	/// Run the command. </summary>
	/// <param name="command_number"> The command number from the processor (0+), used to cross-reference
	/// the log to command instances. </param>
	/// <exception cref="CommandWarningException"> Thrown if non-fatal warnings occur (the
	/// command could produce some results). </exception>
	/// <exception cref="CommandException"> Thrown if fatal warnings occur (the command could not produce output). </exception>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: public void runCommand(int command_number) throws InvalidCommandParameterException, CommandWarningException, CommandException, InterruptedException
	public virtual void runCommand(int command_number)
	{ // Does nothing.
	}

	/// <summary>
	/// Set the command name, as taken from the command string. </summary>
	/// <param name="command_name"> The command name. </param>
	public virtual void setCommandName(string command_name)
	{
		__commandName = command_name;
	}

	/// <summary>
	/// Set a command parameter.  This is used, for example, by a command editor dialog,
	/// and results in command parameter PropList being updated and the command string being regenerated. </summary>
	/// <param name="parameter"> Name of parameter to set. </param>
	/// <param name="value"> Value of parameter to set.  Passing a value of null will
	/// effectively unset the parameter (null will be returned when retrieving the
	/// parameter value, requiring handling). </param>
	public virtual void setCommandParameter(string parameter, string value)
	{ // Handle values with equals with care
		__parameters.set(parameter, value);
		// Refresh the command string...
		__commandString = ToString();
	}

	/// <summary>
	/// Set the command parameters.  This is most often called when the parameters have
	/// been parsed. </summary>
	/// <param name="parameters"> The command parameters as a PropList - only String parameter values are recognized. </param>
	public virtual void setCommandParameters(PropList parameters)
	{
		__parameters = parameters;
		//Refresh the command string...
		__commandString = ToString();
	}

	/// <summary>
	/// Set the command processor.  Normally this is set in the runCommand() method. </summary>
	/// <param name="processor"> The CommandProcessor used to process the command. </param>
	public virtual void setCommandProcessor(CommandProcessor processor)
	{
		__processor = processor;
	}

	/// <summary>
	/// Set the command profile.  This is used, for example, to track command performance (processing time) and
	/// memory usage. </summary>
	/// <param name="phase"> the command phase (currently only CommandPhaseType.RUN is implemented) </param>
	/// <param name="profile"> the command profile </param>
	public virtual void setCommandProfile(CommandPhaseType phase, CommandProfile profile)
	{
		if (phase == CommandPhaseType.RUN)
		{
			__profile = profile;
		}
	}

	/// <summary>
	/// Set the command string.  This is currently used only by the generic command
	/// editor and should only be implemented in this SkeletonCommand base class. </summary>
	/// <param name="command_string"> Command string for the command. </param>
	public virtual void setCommandString(string command_string)
	{
		__commandString = command_string;
	}

	/// <summary>
	/// Set whether the command is a plugin.
	/// This will result in different handling of command data and documentation.
	/// </summary>
	public virtual void setIsCommandPlugin(bool isPlugin)
	{
		this.__isPlugin = isPlugin;
	}

	/// <summary>
	/// Return the command string.  Note that this method is required by the Command
	/// interface.  This version can be relied on to satisfy that requirement. </summary>
	/// <returns> the command string. </returns>
	public override string ToString()
	{
		return ToString(__parameters);
	}

	/// <summary>
	/// Return the command string, formed from the properties.
	/// This is a helper method. This version can be relied on to satisfy
	/// that requirement but in most cases should be overruled.  An attempt is made to
	/// determine the property type and double quote only those that need quoting
	/// (Java Number and Boolean classes are not quoted).
	/// The order of the properties is as added to the property list.
	/// Only properties that are non-null and non-blank are added. </summary>
	/// <param name="props"> properties to output, such from a command editor. </param>
	/// <param name="propOrder"> The list of parameters for the command, in requested order. </param>
	/// <returns> the command string. </returns>
	public virtual string ToString(PropList props, string[] propOrder)
	{
		if ((propOrder == null) || (propOrder.Length == 0))
		{
			// Order is not specified
			return ToString(props);
		}
		StringBuilder b = new StringBuilder();
		string stringValue;
		object contents;
		bool doQuote;
		Prop prop;
		for (int i = 0; i < propOrder.Length; i++)
		{
			doQuote = true; // Default is to quote
			prop = props.getProp(propOrder[i]);
			if (prop == null)
			{
				continue;
			}
			stringValue = prop.getValue();
			contents = prop.getContents();
			if ((contents == null) || (string.ReferenceEquals(stringValue, null)))
			{
				continue;
			}
			if ((contents is Number) || (contents is bool?))
			{
				doQuote = false;
			}
			if (stringValue.Length > 0)
			{
				if (b.Length > 0)
				{
					b.Append(",");
				}
				if (doQuote)
				{
					b.Append(propOrder[i] + "=\"" + stringValue + "\"");
				}
				else
				{
					b.Append(propOrder[i] + "=" + stringValue);
				}
			}
		}
		return (__commandName + "(" + b + ")");
	}

	/// <summary>
	/// Return the command string, formed from the properties.  Note that this method
	/// is required by the Command interface.  This version can be relied on to satisfy
	/// that requirement but in most cases should be overruled.  An attempt is made to
	/// determine the property type and double quote only those that need quoting
	/// (Java Number and Boolean classes are not quoted).
	/// The order of the properties is as added to the property list, which may not be desirable if standard order is expected.
	/// Only properties that are non-null and non-blank are added. </summary>
	/// <param name="parameters"> The list of parameters for the command. </param>
	/// <returns> the command string. </returns>
	public virtual string ToString(PropList parameters)
	{
		if (parameters == null)
		{
			return __commandName + "()";
		}
		StringBuilder b = new StringBuilder();
		string stringValue;
		object contents;
		bool doQuote;
		foreach (Prop prop in parameters.getList())
		{
			doQuote = true; // Default is to quote
			stringValue = prop.getValue();
			contents = prop.getContents();
			if (contents == null)
			{
				continue;
			}
			if ((contents is Number) || (contents is bool?))
			{
				doQuote = false;
			}
			if ((!string.ReferenceEquals(stringValue, null)) && (stringValue.Length > 0))
			{
				if (b.Length > 0)
				{
					b.Append(",");
				}
				if (doQuote)
				{
					b.Append(prop.getKey() + "=\"" + stringValue + "\"");
				}
				else
				{
					b.Append(prop.getKey() + "=" + stringValue);
				}
			}
		}
		return (__commandName + "(" + b + ")");
	}

	}

}