using System;
using System.Collections.Generic;
using System.Text;

// TSUtil_RunningStatistic - create a new time series that is a running statistic of values from the input time series.

/* NoticeStart

CDSS Common Java Library
CDSS Common Java Library is a part of Colorado's Decision Support Systems (CDSS)
Copyright (C) 1994-2019 Colorado Department of Natural Resources

CDSS Common Java Library is free software:  you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    CDSS Common Java Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with CDSS Common Java Library.  If not, see <https://www.gnu.org/licenses/>.

NoticeEnd */

namespace RTi.TS
{

	using DistributionType = RTi.Util.Math.DistributionType;
	using MathUtil = RTi.Util.Math.MathUtil;
	using SortOrderType = RTi.Util.Math.SortOrderType;
	using Message = RTi.Util.Message.Message;
	using DateTime = RTi.Util.Time.DateTime;
	using TimeInterval = RTi.Util.Time.TimeInterval;
	using TimeUtil = RTi.Util.Time.TimeUtil;

	/// <summary>
	/// Create a new time series that is a running statistic of values from the input time series.
	/// </summary>
	public class TSUtil_RunningStatistic
	{

	/// <summary>
	/// Time series to process.
	/// </summary>
	private TS __ts = null;

	/// <summary>
	/// Analysis start.
	/// </summary>
	private DateTime __analysisStart = null;

	/// <summary>
	/// Analysis end.
	/// </summary>
	private DateTime __analysisEnd = null;

	/// <summary>
	/// Normal start.
	/// </summary>
	private DateTime __normalStart = null;

	/// <summary>
	/// Normal end.
	/// </summary>
	private DateTime __normalEnd = null;

	/// <summary>
	/// Output start.
	/// </summary>
	private DateTime __outputStart = null;

	/// <summary>
	/// Output end.
	/// </summary>
	private DateTime __outputEnd = null;

	/// <summary>
	/// Sample type.
	/// </summary>
	private RunningAverageType __SampleType = null;

	/// <summary>
	/// Statistic.
	/// </summary>
	private TSStatisticType __statistic = null;

	/// <summary>
	/// Bracket (N) for N-year running statistic, as per the running average type.
	/// </summary>
	private int __n;

	/// <summary>
	/// Bracket (N) for N-year running statistic, as per the running average type, by month.
	/// This will override the singular value.  If any value is null, skip the month in calculating the statistic.
	/// </summary>
	private int?[] __nByMonth = null;

	/// <summary>
	/// Custom bracket (N) for N-year running statistic, as per the running average type, by month.
	/// This will override the singular value and month values.
	/// The dimension will be [12][2] where [][0] is the first offset and [][1] is the second offset for the range.
	/// If any row is null, skip the month in calculating the statistic.
	/// </summary>
	private int?[][] __nCustomByMonth = null;

	/// <summary>
	/// Number of missing values allowed in the sample.
	/// </summary>
	private int __allowMissingCount;

	/// <summary>
	/// Minimum sample size to do a calculation.
	/// </summary>
	private int __minimumSampleSize;

	/// <summary>
	/// Distribution.
	/// </summary>
	private DistributionType __distribution = null;

	/// <summary>
	/// Distribution parameters.
	/// </summary>
	private Dictionary<string, string> __distributionParameters = null;

	/// <summary>
	/// Units to use for probabilities, "Fraction", "Percent", or "%".
	/// </summary>
	private string __probabilityUnits = "Fraction"; // default

	/// <summary>
	/// Sort order type.
	/// </summary>
	private SortOrderType __sortOrderType = null;

	/// <summary>
	/// List of problems generated by this command, guaranteed to be non-null.
	/// </summary>
	private IList<string> __problems = new List<string>();

	/// <summary>
	/// Construct the object and check for valid input. </summary>
	/// <param name="ts"> regular-interval time series for which to create the running average time series </param>
	/// <param name="n"> N for N-year running statistic and otherwise the bracket for centered,
	/// previous, and future running statistics </param>
	/// <param name="nByMonth"> same as "n" but 12 values, one for each month (Jan,Feb,...,Dec) </param>
	/// <param name="nCustomByMonth"> same as "n" but 12 ranges with start and start offset </param>
	/// <param name="statisticType"> statistic to compute </param>
	/// <param name="sampleType"> type of data sampling for statistic </param>
	/// <param name="allowMissingCount"> the number of values allowed to be missing in the sample (for example can set to 5 for
	/// 30-year running average to limit impacts of occasional missing data) </param>
	/// <param name="minimumSampleSize"> for sample methods that don't specify the sample size (like NYear), specify the minimum sample
	/// size to do the calculation, or -1 if the sample size does not matter </param>
	/// <param name="distributionType"> distribution type (used with Rank, PlottingPosition, *Exceedance* </param>
	/// <param name="distributionParameters"> parameters used by distribution, e.g., coefficients </param>
	/// <param name="probabilityUnits"> units to use for probability statistics ("Fraction", "Percent", or "%" - default is "Fraction"). </param>
	/// <param name="sortOrderType"> sort order type needed by some statistics (e.g. Rank, PlottingPosition, *Exceedance*) </param>
	/// <param name="normalStart"> date/time for start of normal period </param>
	/// <param name="normalEnd"> date/time for end of normal period </param>
	/// <param name="outputStart"> date/time for start of output time series </param>
	/// <param name="outputEnd"> date/time for end of output time series </param>
	public TSUtil_RunningStatistic(TS ts, int n, Integer[] nByMonth, Integer[][] nCustomByMonth, TSStatisticType statisticType, DateTime analysisStart, DateTime analysisEnd, RunningAverageType sampleType, int allowMissingCount, int minimumSampleSize, DistributionType distributionType, Dictionary<string, string> distributionParameters, string probabilityUnits, SortOrderType sortOrderType, DateTime normalStart, DateTime normalEnd, DateTime outputStart, DateTime outputEnd)
	{
		string message;
//JAVA TO C# CONVERTER WARNING: The .NET Type.FullName property will not always yield results identical to the Java Class.getName method:
		string routine = this.GetType().FullName;

		if (ts == null)
		{
			message = "Input time series is null.";
			Message.printWarning(2, routine, message);
			throw new InvalidParameterException(message);
		}

		if (ts.getDataIntervalBase() == TimeInterval.IRREGULAR)
		{
			message = "Converting irregular time series to running statistic is not supported.";
			Message.printWarning(2, routine, message);
			throw new IrregularTimeSeriesNotSupportedException(message);
		}

		bool found = false;
		foreach (TSStatisticType s in getStatisticChoices())
		{
			if (s == statisticType)
			{
				found = true;
				break;
			}
		}
		if (!found)
		{
			message = "Statistic \"" + statisticType + "\" is not supported.";
			Message.printWarning(2, routine, message);
			throw new InvalidParameterException(message);
		}

		found = false;
		foreach (DistributionType d in getDistributionChoices())
		{
			if (d == distributionType)
			{
				found = true;
				break;
			}
		}
		if (!found)
		{
			message = "Distribution \"" + distributionType + "\" is not supported.";
			Message.printWarning(2, routine, message);
			throw new InvalidParameterException(message);
		}
		else
		{
			if (distributionType == DistributionType.GRINGORTEN)
			{
				if ((distributionParameters == null) || (string.ReferenceEquals(distributionParameters["a"], null)))
				{
					message = "Distribution " + DistributionType.GRINGORTEN +
						" requires that the coefficent \"a\" is specified in distribution parameters.";
					Message.printWarning(2, routine, message);
					throw new InvalidParameterException(message);
				}
			}
		}
		// TODO SAM 2013-12-17 The low level code currently deals with this
		// Make sure exceedance and nonexceedance probabilities are sorting the right way
		//if ( (statisticType == TSStatisticType.EXCEEDANCE_PROBABILITY) || (statisticType == TSStatisticType.NONEXCEEDANCE_PROBABILITY) ) {
		//    if ( (sortOrderType != null) && (sortOrderType != SortOrderType.HIGH_TO_LOW) ) {
		//        message = "Statistic " + statisticType +
		//            " internally specifies the sort order as " + SortOrderType.HIGH_TO_LOW + " which is different from the requested sort order";
		//        Message.printWarning ( 2, routine, message );
		//    }
		//}

		setAnalysisStart(analysisStart);
		setAnalysisEnd(analysisEnd);

		setNormalStart(normalStart);
		setNormalEnd(normalEnd);

		if ((normalStart != null) && (normalEnd != null) && (sampleType != RunningAverageType.ALL_YEARS))
		{
			message = "If normal period is specified, the sample type type must be " + RunningAverageType.ALL_YEARS +
				" (" + sampleType + " is specified).";
			Message.printWarning(2, routine, message);
			throw new InvalidParameterException(message);
		}

		setOutputStart(outputStart);
		setOutputEnd(outputEnd);

		found = false;
		foreach (RunningAverageType t in getRunningAverageTypeChoices())
		{
			if (t == sampleType)
			{
				found = true;
				break;
			}
		}
		if (!found)
		{
			message = "Sample type type \"" + sampleType + "\" is not supported.";
			Message.printWarning(2, routine, message);
			throw new InvalidParameterException(message);
		}

		setTS(ts);
		setN(n);
		setNByMonth(nByMonth);
		setNCustomByMonth(nCustomByMonth);
		setStatisticType(statisticType);
		setDistributionType(distributionType);
		setDistributionParameters(distributionParameters);
		setSortOrderType(sortOrderType);
		setSampleType(sampleType);
		setAllowMissingCount(allowMissingCount);
		setMinimumSampleSize(minimumSampleSize);
		if ((string.ReferenceEquals(probabilityUnits, null)) || probabilityUnits.Equals(""))
		{
			probabilityUnits = "Fraction";
		}
		if ((probabilityUnits.Equals("Fraction", StringComparison.OrdinalIgnoreCase) || probabilityUnits.Equals("Percent", StringComparison.OrdinalIgnoreCase) || probabilityUnits.Equals("%")))
		{
			// Only override default of Fraction if recognized units
			setProbabilityUnits(probabilityUnits);
		}
		else
		{
			message = "Probability units \"" + probabilityUnits + "\" is not supported.";
			Message.printWarning(2, routine, message);
			throw new InvalidParameterException(message);
		}
	}

	/// <summary>
	/// Return the offset data for a month. </summary>
	/// <returns> offset data as array { offset1, offset2, neededCount } or null if monthly values and the month n is null. </returns>
	public virtual int [] calculateOffsetData(RunningAverageType sampleType, int month, int n, Integer[] nByMonth, bool doNByMonth, Integer[][] nCustomByMonth, bool doNCustomByMonth, TS newts)
	{
		int[] offsetData = new int[3];
		offsetData[0] = 0; // offset1
		offsetData[1] = 0; // offset2
		offsetData[2] = 0; // neededCount
		int month0 = month - 1; // position in zero index array
		if (doNByMonth)
		{
			// Reset N for the monthly value
			if (nByMonth[month0] == null)
			{
				return null;
			}
			n = nByMonth[month0];
		}
		else if (doNCustomByMonth)
		{
			if ((nCustomByMonth[month0][0] == null) || (nCustomByMonth[month0][1] == null))
			{
				return null;
			}
			else
			{
				offsetData[0] = nCustomByMonth[month0][0];
				offsetData[1] = nCustomByMonth[month0][1];
				offsetData[2] = offsetData[1] - offsetData[0] + 1;
				return offsetData;
			}
		}
		if (sampleType == RunningAverageType.ALL_YEARS)
		{
		}
		else if (sampleType == RunningAverageType.N_ALL_YEAR)
		{
			offsetData[2] = newts.getDate2().getYear() - newts.getDate1().getYear() + 1;
		}
		else if (sampleType == RunningAverageType.CENTERED)
		{
			// Offset is on each side
			offsetData[0] = -1 * n;
			offsetData[1] = n;
			offsetData[2] = n * 2 + 1;
		}
		else if (sampleType == RunningAverageType.FUTURE)
		{
			// Offset brackets the date...
			offsetData[0] = 1;
			offsetData[1] = n;
			offsetData[2] = n;
		}
		else if (sampleType == RunningAverageType.FUTURE_INCLUSIVE)
		{
			// Offset brackets the date...
			offsetData[0] = 0;
			offsetData[1] = n;
			offsetData[2] = n + 1;
		}
		else if (sampleType == RunningAverageType.NYEAR)
		{
			// Offset is to the left but remember to include the time step itself...
			offsetData[0] = -1 * (n - 1);
			offsetData[1] = 0;
			offsetData[2] = n;
		}
		else if (sampleType == RunningAverageType.PREVIOUS)
		{
			// Offset brackets the date...
			offsetData[0] = -n;
			offsetData[1] = -1;
			offsetData[2] = n;
		}
		else if (sampleType == RunningAverageType.PREVIOUS_INCLUSIVE)
		{
			// Offset brackets the date...
			offsetData[0] = -n;
			offsetData[1] = 0;
			offsetData[2] = n + 1;
		}
		return offsetData;
	}

	/// <summary>
	/// Return the number of allowed missing values in the sample.
	/// </summary>
	public virtual int getAllowMissingCount()
	{
		return __allowMissingCount;
	}

	/// <summary>
	/// Return the analysis end.
	/// </summary>
	public virtual DateTime getAnalysisEnd()
	{
		return __analysisEnd;
	}

	/// <summary>
	/// Return the analysis start.
	/// </summary>
	public virtual DateTime getAnalysisStart()
	{
		return __analysisStart;
	}

	/// <summary>
	/// Get the list of distributions that can be used in calculations.
	/// </summary>
	public static IList<DistributionType> getDistributionChoices()
	{
		// Enable statistics that illustrate how things change over time
		IList<DistributionType> choices = new List<DistributionType>();
		choices.Add(DistributionType.GRINGORTEN);
		choices.Add(DistributionType.WEIBULL);
		return choices;
	}

	/// <summary>
	/// Get the list of distributions that can be calculated. </summary>
	/// <returns> the distribution display names as strings. </returns>
	public static IList<string> getDistributionChoicesAsStrings()
	{
		IList<DistributionType> choices = getDistributionChoices();
		IList<string> stringChoices = new List<string>();
		for (int i = 0; i < choices.Count; i++)
		{
			stringChoices.Add("" + choices[i]);
		}
		return stringChoices;
	}

	/// <summary>
	/// Return the distribution parameters.
	/// </summary>
	public virtual Dictionary<string, string> getDistributionParameters()
	{
		return __distributionParameters;
	}

	/// <summary>
	/// Return the distribution type.
	/// </summary>
	public virtual DistributionType getDistributionType()
	{
		return __distribution;
	}

	/// <summary>
	/// Return the minimum sample size.
	/// </summary>
	public virtual int getMinimumSampleSize()
	{
		return __minimumSampleSize;
	}

	/// <summary>
	/// Return the N-year N or bracket.
	/// </summary>
	public virtual int getN()
	{
		return __n;
	}

	/// <summary>
	/// Return the N-year N or bracket (monthly array).
	/// </summary>
	public virtual int? [] getNByMonth()
	{
		return __nByMonth;
	}

	/// <summary>
	/// Return the custom N-year N or bracket (monthly array).
	/// </summary>
	public virtual int? [][] getNCustomByMonth()
	{
		return __nCustomByMonth;
	}

	/// <summary>
	/// Return the normal end.
	/// </summary>
	public virtual DateTime getNormalEnd()
	{
		return __normalEnd;
	}

	/// <summary>
	/// Return the normal start.
	/// </summary>
	public virtual DateTime getNormalStart()
	{
		return __normalStart;
	}

	/// <summary>
	/// Return the output end.
	/// </summary>
	public virtual DateTime getOutputEnd()
	{
		return __outputEnd;
	}

	/// <summary>
	/// Return the output start.
	/// </summary>
	public virtual DateTime getOutputStart()
	{
		return __outputStart;
	}

	/// <summary>
	/// Return the probability units.
	/// </summary>
	public virtual string getProbabilityUnits()
	{
		return __probabilityUnits;
	}

	/// <summary>
	/// Return a list of problems for the time series.
	/// </summary>
	public virtual IList<string> getProblems()
	{
		return __problems;
	}

	/// <summary>
	/// Return the running statistic sample types that are supported by the class.
	/// </summary>
	public static RunningAverageType[] getRunningAverageTypeChoices()
	{
		RunningAverageType[] types = new RunningAverageType[] {RunningAverageType.ALL_YEARS, RunningAverageType.CENTERED, RunningAverageType.CUSTOM, RunningAverageType.FUTURE, RunningAverageType.FUTURE_INCLUSIVE, RunningAverageType.NYEAR, RunningAverageType.N_ALL_YEAR, RunningAverageType.PREVIOUS, RunningAverageType.PREVIOUS_INCLUSIVE};
		return types;
	}

	/// <summary>
	/// Return the sample window type.
	/// </summary>
	public virtual RunningAverageType getSampleType()
	{
		return __SampleType;
	}

	/// <summary>
	/// Return the sort order type.
	/// </summary>
	public virtual SortOrderType getSortOrderType()
	{
		return __sortOrderType;
	}

	/// <summary>
	/// Get the list of statistics that can be performed.
	/// These are primary statistics types; however, other data may be needed to fully describe the statistic.  For example,
	/// Rank and PlottingPosition depend on the sort order and PlottingPosition depends on the distribution.  Consequently,
	/// other code must enforce these properties and provide transparency to users.
	/// </summary>
	public static IList<TSStatisticType> getStatisticChoices()
	{
		// Enable statistics that illustrate how things change over time
		IList<TSStatisticType> choices = new List<TSStatisticType>();
		choices.Add(TSStatisticType.EXCEEDANCE_PROBABILITY);
		choices.Add(TSStatisticType.GEOMETRIC_MEAN);
		choices.Add(TSStatisticType.LAG1_AUTO_CORRELATION);
		choices.Add(TSStatisticType.MAX);
		choices.Add(TSStatisticType.MEAN);
		choices.Add(TSStatisticType.MEDIAN);
		choices.Add(TSStatisticType.MIN);
		choices.Add(TSStatisticType.NONEXCEEDANCE_PROBABILITY);
		choices.Add(TSStatisticType.PERCENT_OF_MAX);
		choices.Add(TSStatisticType.PERCENT_OF_MEDIAN);
		choices.Add(TSStatisticType.PERCENT_OF_MEAN);
		choices.Add(TSStatisticType.PERCENT_OF_MIN);
		choices.Add(TSStatisticType.PLOTTING_POSITION);
		choices.Add(TSStatisticType.RANK);
		choices.Add(TSStatisticType.SKEW);
		choices.Add(TSStatisticType.STD_DEV);
		choices.Add(TSStatisticType.TOTAL);
		choices.Add(TSStatisticType.VARIANCE);
		return choices;
	}

	/// <summary>
	/// Get the list of statistics that can be calculated. </summary>
	/// <returns> the statistic display names as strings. </returns>
	public static IList<string> getStatisticChoicesAsStrings()
	{
		IList<TSStatisticType> choices = getStatisticChoices();
		IList<string> stringChoices = new List<string>();
		for (int i = 0; i < choices.Count; i++)
		{
			stringChoices.Add("" + choices[i]);
		}
		return stringChoices;
	}

	/// <summary>
	/// Return the running statistic type.
	/// </summary>
	public virtual TSStatisticType getStatisticType()
	{
		return __statistic;
	}

	/// <summary>
	/// Return the input time series being processed.
	/// </summary>
	public virtual TS getTS()
	{
		return __ts;
	}

	/// <summary>
	/// Create a running average time series where the time series value is the
	/// average of 1 or more values from the original time series.  The description is
	/// appended with ", centered [N] running average" or ", N-year running average", etc. </summary>
	/// <returns> The new running statistic time series, which is a copy of the original metadata
	/// but with data being the running statistic. </returns>
	/// <exception cref="RTi.TS.TSException"> if there is a problem creating and filling the new time series. </exception>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: public TS runningStatistic(boolean createData) throws TSException, IrregularTimeSeriesNotSupportedException
	public virtual TS runningStatistic(bool createData)
	{
		string genesis = "", message, routine = this.GetType().Name + ".runningStatistic";
		TS newts = null;
		TS newts2 = null; // Used when normal period is used (newts is statistic for normal period, newts2 is final output)

		TS ts = getTS();
		TSStatisticType statisticType = getStatisticType();
		DistributionType distributionType = getDistributionType();
		Dictionary<string, string> distributionParameters = getDistributionParameters();
		SortOrderType sortOrderType = getSortOrderType();
		DateTime analysisStart = getAnalysisStart();
		DateTime analysisEnd = getAnalysisEnd();
		DateTime normalStart = getNormalStart();
		DateTime normalEnd = getNormalEnd();
		DateTime outputStart = getOutputStart();
		DateTime outputEnd = getOutputEnd();
		RunningAverageType sampleType = getSampleType();
		int n = getN();
		int?[] nByMonth = getNByMonth();
		int?[][] nCustomByMonth = getNCustomByMonth();
		bool doNByMonth = false;
		bool doNCustomByMonth = false;
		if ((nByMonth != null) && (nByMonth.Length == 12))
		{
			doNByMonth = true;
		}
		if ((nCustomByMonth != null) && (nCustomByMonth.Length == 12))
		{
			doNByMonth = false;
			doNCustomByMonth = true;
		}
		int allowMissingCount = getAllowMissingCount();
		int minimumSampleSize = getMinimumSampleSize();
		if (minimumSampleSize <= 0)
		{
			// Not specified so require at least 1 value, mainly to keep the analysis going
			minimumSampleSize = 1;
		}

		// Set the data type in the new time series to reflect the running statistic
		string statString = "" + statisticType;
		if (sampleType == RunningAverageType.NYEAR)
		{
			statString = "" + n + statisticType;
		}
		/* TODO SAM 2013-09-13 Why is this here?  Does not make sense for all the new statistics
		if ( (sampleType != RunningAverageType.N_ALL_YEAR) && (sampleType != RunningAverageType.ALL_YEARS) && (n == 0) ) {
		    // NoReturn a copy of the original time series
		    //
		    newts = (TS)ts.clone();
		    newts.setDataType(ts.getDataType() + "-Running-" + statString );
		    return newts;
		}
		*/

		// Handling of specific statistics...

		// Some statistics are a manipulation of a "normal period" statistic. For example, "PercentOfMean" requires an
		// initial statistic (Mean) to be calculated for the normal period and then the input time series value is used to compute
		// the final statistic.  Use statisticTypeForNormal to save the final statistic.  The process is as follows:
		// 1) Compute the statistic for the normal period (may be the same as the analysis period)
		// 2) Use the results from 1 to compute the output for the analysis period
		TSStatisticType statisticTypeForNormal = null;
		double unitsMult = 1.0; // Used for probability conversion from fraction
		string newUnits = null;
		if ((statisticType == TSStatisticType.LAG1_AUTO_CORRELATION) || (statisticType == TSStatisticType.PLOTTING_POSITION) || (statisticType == TSStatisticType.RANK) || (statisticType == TSStatisticType.SKEW))
		{
			newUnits = "";
		}
		else if ((statisticType == TSStatisticType.EXCEEDANCE_PROBABILITY) || (statisticType == TSStatisticType.NONEXCEEDANCE_PROBABILITY))
		{
			newUnits = getProbabilityUnits();
			if (newUnits.Equals("Percent", StringComparison.OrdinalIgnoreCase) || newUnits.Equals("%", StringComparison.OrdinalIgnoreCase))
			{
				// Conversion from fraction to percent
				unitsMult = 100.0;
			}
		}
		else if ((statisticType == TSStatisticType.PERCENT_OF_MEAN) || (statisticType == TSStatisticType.PERCENT_OF_MEDIAN) || (statisticType == TSStatisticType.PERCENT_OF_MAX) || (statisticType == TSStatisticType.PERCENT_OF_MIN))
		{
			newUnits = "Percent";
			statisticTypeForNormal = statisticType; // Assign to original requested statistic
			// Reset the statistic type to calculate the first statistic time series
			if (statisticType == TSStatisticType.PERCENT_OF_MEAN)
			{
				statisticType = TSStatisticType.MEAN;
			}
			else if (statisticType == TSStatisticType.PERCENT_OF_MEDIAN)
			{
				statisticType = TSStatisticType.MEDIAN;
			}
			else if (statisticType == TSStatisticType.PERCENT_OF_MAX)
			{
				statisticType = TSStatisticType.MAX;
			}
			else if (statisticType == TSStatisticType.PERCENT_OF_MIN)
			{
				statisticType = TSStatisticType.MIN;
			}
		}
		else if (statisticType == TSStatisticType.VARIANCE)
		{
			string units = ts.getDataUnits();
			newUnits = units + "^2";
		}

		// Create a new time series of the proper type...

		int intervalBase = ts.getDataIntervalBase();
		int intervalMult = ts.getDataIntervalMult();
		string newInterval = "" + intervalMult + TimeInterval.getName(intervalBase,1);
		try
		{
			newts = TSUtil.newTimeSeries(newInterval, false);
			if (statisticTypeForNormal != null)
			{
				newts2 = TSUtil.newTimeSeries(newInterval, false);
			}
		}
		catch (Exception)
		{
			message = "Unable to create new time series of interval \"" + newInterval + "\"";
			Message.printWarning(3, routine, message);
			throw new Exception(message);
		}
		newts.copyHeader(ts);
		newts.setDataType(ts.getDataType() + "-Running-" + statString);
		// If the output period is not specified, use the full time series period
		if (outputStart == null)
		{
			outputStart = new DateTime(ts.getDate1());
		}
		newts.setDate1(outputStart);
		if (outputEnd == null)
		{
			outputEnd = new DateTime(ts.getDate2());
		}
		newts.setDate2(outputEnd);
		if (!string.ReferenceEquals(newUnits, null))
		{
			newts.setDataUnits(newUnits);
		}
		if (statisticTypeForNormal != null)
		{
			// Initial calculation...
			newts.setDate1(normalStart);
			newts.setDate2(normalEnd);
			// Final output...
			newts2.copyHeader(ts); // Includes units
			newts2.setDataType(ts.getDataType() + "-Running-" + statString);
			newts2.setDate1(outputStart);
			newts2.setDate2(outputEnd);
			if (!string.ReferenceEquals(newUnits, null))
			{
				newts2.setDataUnits(newUnits);
			}
		}
		// Set the analysis period to the output end if not specified
		// Have to do here because output start may be determine from the time series
		if (analysisStart == null)
		{
			analysisStart = new DateTime(outputStart);
		}
		if (analysisEnd == null)
		{
			analysisEnd = new DateTime(outputEnd);
		}
		// Make an additional adjustment to the normal period
		if ((statisticType == TSStatisticType.PERCENT_OF_MEAN) || (statisticType == TSStatisticType.PERCENT_OF_MEDIAN) || (statisticType == TSStatisticType.PERCENT_OF_MAX) || (statisticType == TSStatisticType.PERCENT_OF_MIN))
		{
			string note1 = "", note2 = "";
			if (normalStart == null)
			{
				normalStart = new DateTime(analysisStart);
				note1 = " (set to AnalysisStart)";
			}
			if (normalEnd == null)
			{
				normalEnd = new DateTime(analysisEnd);
				note2 = " (set to AnalysisEnd)";
			}
			Message.printStatus(2,routine,"Will compute " + statisticType + " statistic first as input to final " + statisticTypeForNormal + " statistic using normal period " + normalStart + note1 + " to " + normalEnd + note2);
		}
		int neededCountWithAllowMissing = 0; // Needed count adjusted for allowed missing
		if (createData)
		{
			// Actually create the data (otherwise only the header information is populated)
			newts.allocateDataSpace();
			if (statisticTypeForNormal != null)
			{
				newts2.allocateDataSpace();
			}

			// Set the offsets for getting data around the current date/time

			int neededCount = 0; // Used initially to size the sample array
			int offset1 = 0;
			int offset2 = 0;
			if (!doNByMonth && !doNCustomByMonth)
			{
				// Calculate offsets for the constant N
				int[] offsetData0 = calculateOffsetData(sampleType, 0, n, nByMonth, doNByMonth, nCustomByMonth, doNCustomByMonth, newts);
				offset1 = offsetData0[0];
				offset2 = offsetData0[1];
				neededCount = offsetData0[2];
			}
			int neededCountMax = neededCount;
			StringBuilder genesisMonth = null;
			if (doNByMonth || doNCustomByMonth)
			{
				// Calculate the maximum neededCount, to size the sample data array
				genesisMonth = new StringBuilder();
				bool initialized = false;
				for (int i = 1; i <= 12; i++)
				{
					int[] offsetData0 = calculateOffsetData(sampleType, i, 0, nByMonth, doNByMonth, nCustomByMonth, doNCustomByMonth, newts);
					if (offsetData0 != null)
					{
						if (!initialized)
						{
							neededCountMax = offsetData0[2];
							initialized = true;
						}
						else if (offsetData0[2] > neededCountMax)
						{
							neededCountMax = offsetData0[2];
						}
					}
					// Build the genesis string
					if (i >= 2)
					{
						genesisMonth.Append(",");
					}
					if (doNByMonth)
					{
						if (nByMonth[i - 1] == null)
						{
							genesisMonth.Append("");
						}
						else
						{
							genesisMonth.Append("" + nByMonth[i - 1]);
						}
					}
					else if (doNCustomByMonth)
					{
						if ((nCustomByMonth[i - 1][0] == null) || (nCustomByMonth[i - 1][1] == null))
						{
							genesisMonth.Append("");
						}
						else
						{
							genesisMonth.Append("" + nCustomByMonth[i - 1][0] + "-" + nCustomByMonth[i - 1][1]);
						}
					}
				}
			}
			// Set the string for the time series modification history
			if (sampleType == RunningAverageType.ALL_YEARS)
			{
				genesis = "" + sampleType;
			}
			else if (sampleType == RunningAverageType.N_ALL_YEAR)
			{
				genesis = "NAll-year";
			}
			else if (sampleType == RunningAverageType.CENTERED)
			{
				if (doNByMonth)
				{
					genesis = "bracket=" + genesisMonth + " centered";
				}
				else
				{
					genesis = "bracket=" + n + " centered";
				}
			}
			else if (sampleType == RunningAverageType.FUTURE)
			{
				if (doNByMonth)
				{
					genesis = "bracket=" + genesisMonth + " future (not inclusive)";
				}
				else
				{
					genesis = "bracket=" + n + " future (not inclusive)";
				}
			}
			else if (sampleType == RunningAverageType.FUTURE_INCLUSIVE)
			{
				if (doNByMonth)
				{
					genesis = "bracket=" + genesisMonth + " future (inclusive)";
				}
				else
				{
					genesis = "bracket=" + n + " future (inclusive)";
				}
			}
			else if (sampleType == RunningAverageType.NYEAR)
			{
				  genesis = n + "-year";
			}
			else if (sampleType == RunningAverageType.PREVIOUS)
			{
				if (doNByMonth)
				{
					genesis = "bracket=" + genesisMonth + " previous (not inclusive)";
				}
				else
				{
					genesis = "bracket=" + n + " previous (not inclusive)";
				}
			}
			else if (sampleType == RunningAverageType.PREVIOUS_INCLUSIVE)
			{
				if (doNByMonth)
				{
					genesis = "bracket=" + genesisMonth + " previous (inclusive)";
				}
				else
				{
					genesis = "bracket=" + n + " previous (inclusive)";
				}
			}

			// Adjusted the number of needed values to allow for missing

			neededCountWithAllowMissing = neededCount;
			if (allowMissingCount > 0)
			{
				neededCountWithAllowMissing -= allowMissingCount;
			}

			// Size the sample array (count will be <= the max and control the calculations)
			// The "count" is used to indicate how big the sample is for calculations
			double[] sampleArray = new double[neededCountMax];
			// Used for AllYears sample method.  Size for the number of years in the analysis period (will be more than enough).
			// Use the newts date/times because they will match the analysis period or the full period of the original time series
			DateTime start = new DateTime(analysisStart);
			DateTime end = new DateTime(analysisEnd);
			TSData[] sampleArrayTSData; // = new TSData[end.getYear() - start.getYear() + 1];

			// Iterate through the full period of the output time series

			// Analysis period is used for calculations unless normal period is specified
			// Analysis period is set to output period if not specified.
			if (statisticTypeForNormal != null)
			{
				if (normalStart != null)
				{
					start = new DateTime(normalStart);
				}
				if (normalEnd != null)
				{
					end = new DateTime(normalEnd);
				}
			}
			DateTime date = new DateTime(start);
			DateTime valueDateTime = new DateTime(newts.getDate1()); // Used to access data values for statistic
			int count, i;
			double value = 0.0;
			double missing = ts.getMissing();
			bool doCalc = true;
			Dictionary<string, double []> valueCache = new Dictionary<string, double[]>();
			int month;
			int[] offsetData;
			for (; date.lessThanOrEqualTo(end); date.addInterval(intervalBase, intervalMult))
			{
				// Initialize the date for looking up values to the initial offset from the loop date (new lines up with old)
				valueDateTime.setDate(date);
				if (doNByMonth || doNCustomByMonth)
				{
					// Calculate values needed to compute statistic using monthly N (bracket)
					month = valueDateTime.getMonth();
					offsetData = calculateOffsetData(sampleType, month, n, nByMonth, doNByMonth, nCustomByMonth, doNCustomByMonth, newts);
					if (offsetData == null)
					{
						// No offset was specified so don't calculate the output statistic
						continue;
					}
					offset1 = offsetData[0];
					offset2 = offsetData[1];
					neededCount = offsetData[2];
					neededCountWithAllowMissing = neededCount;
					if (allowMissingCount > 0)
					{
						neededCountWithAllowMissing -= allowMissingCount;
					}
				}
				// Offset from the current date/time to the start of the bracket
				if (sampleType == RunningAverageType.NYEAR)
				{
					valueDateTime.addInterval(TimeInterval.YEAR, offset1);
				}
				else if (sampleType == RunningAverageType.N_ALL_YEAR)
				{
					// Reset to the start of the period and set the offsets to process the start year to the
					// current year
					valueDateTime.setYear(newts.getDate1().getYear());
					if (valueDateTime.lessThan(newts.getDate1()))
					{
						// Has wrapped around since the first date/time was not the start of a year so add another year
						valueDateTime.addYear(1);
					}
					offset1 = valueDateTime.getYear();
					offset2 = date.getYear();
				}
				else
				{
					valueDateTime.addInterval(intervalBase, offset1 * intervalMult);
				}
				// Get the sample for the calculation
				count = 0;
				string key = null;
				if (sampleType == RunningAverageType.ALL_YEARS)
				{
					// This will be slow if the values have to be extracted each time.  Because the array will be
					// the same each request, cache at the appropriate time resolution. For example, if processing annual
					// data, only one array is needed.  If monthly data, 12 arrays are needed.
					// Get the values for all years (false at end means exclude missing)
					if (intervalBase == TimeInterval.DAY)
					{
						key = "" + date.getMonth() + "-" + date.getDay();
						sampleArray = valueCache[key];
					}
					else if (intervalBase == TimeInterval.MONTH)
					{
						key = "" + date.getMonth();
						sampleArray = valueCache[key];
					}
					else if (intervalBase == TimeInterval.YEAR)
					{
						key = "year";
						sampleArray = valueCache[key];
					}
					if (sampleArray == null)
					{
						// Generate array and save in cache, ignoring missing values
						sampleArrayTSData = TSUtil.toArrayForDateTime(ts, start, end, date, false);
						if (sampleArrayTSData == null)
						{
							sampleArrayTSData = new TSData[0];
						}
						sampleArray = new double[sampleArrayTSData.Length];
						for (int @is = 0; @is < sampleArrayTSData.Length; @is++)
						{
							sampleArray[@is] = sampleArrayTSData[@is].getDataValue();
							//Message.printStatus(2,routine,"Sample for value date/time " + valueDateTime + " value[" + is + "]=" + sampleArray[is]);
						}
						valueCache[key] = sampleArray;
					}
					// Reset the count based on the sample array size
					count = sampleArray.Length;
				}
				else
				{
					// Loop through the intervals in the bracket and get the sample set...
					for (i = offset1; i <= offset2; i++)
					{
						// This check should fail harmlessly if dealing with intervals greater than a day
						if ((valueDateTime.getMonth() == 2) && (valueDateTime.getDay() == 29) && !TimeUtil.isLeapYear(valueDateTime.getYear()))
						{
							// The Feb 29 that we are requesting in another year does not exist.  Set to missing
							// This will result in the final output also being missing.
							value = missing;
						}
						else
						{
							// Normal data access.
							value = ts.getDataValue(valueDateTime);
						}
						if (!ts.isDataMissing(value))
						{
							// Add the value to the sample (which has been initialized to zero above...
							sampleArray[count++] = value;
						}
						// Reset the dates for the input data value...
						if ((sampleType == RunningAverageType.NYEAR) || (sampleType == RunningAverageType.N_ALL_YEAR))
						{
							// Get the value for the next year (last value will be the current year).
							valueDateTime.addInterval(TimeInterval.YEAR, 1);
						}
						else
						{
							// Just move forward incrementally between end points
							valueDateTime.addInterval(intervalBase, intervalMult);
						}
					}
				}
				// Now set the data value to the computed statistic...
				doCalc = false;
				if (sampleType == RunningAverageType.ALL_YEARS)
				{
					if (count >= minimumSampleSize)
					{
						doCalc = true;
					}
				}
				else if (sampleType == RunningAverageType.N_ALL_YEAR)
				{
					if (count >= minimumSampleSize)
					{
						doCalc = true;
					}
				}
				else if (count >= neededCountWithAllowMissing)
				{
					if (count > 0)
					{
						doCalc = true;
					}
				}
				if (doCalc)
				{
					// Handle the statistics that are supported...
					try
					{
						if (statisticType == TSStatisticType.LAG1_AUTO_CORRELATION)
						{
							newts.setDataValue(date,MathUtil.lagAutoCorrelation(count, sampleArray, 1));
						}
						else if (statisticType == TSStatisticType.EXCEEDANCE_PROBABILITY)
						{
							value = ts.getDataValue(date);
							if (!ts.isDataMissing(value))
							{
								// The value will also be in the array so it should exactly match an exceedance
								// probability.  The following algorithm will interpolate if necessary but the value
								// will be very near a calculated value.
								newts.setDataValue(date,MathUtil.exceedanceProbability(count, sampleArray, value) * unitsMult);
							}
						}
						else if (statisticType == TSStatisticType.GEOMETRIC_MEAN)
						{
							newts.setDataValue(date,MathUtil.geometricMean(count, sampleArray));
						}
						else if (statisticType == TSStatisticType.MAX)
						{
							newts.setDataValue(date,MathUtil.max(count, sampleArray));
						}
						else if (statisticType == TSStatisticType.MEAN)
						{
							newts.setDataValue(date,MathUtil.mean(count, sampleArray));
						}
						else if (statisticType == TSStatisticType.MEDIAN)
						{
							newts.setDataValue(date,MathUtil.median(count, sampleArray));
						}
						else if (statisticType == TSStatisticType.MIN)
						{
							newts.setDataValue(date,MathUtil.min(count, sampleArray));
						}
						else if (statisticType == TSStatisticType.NONEXCEEDANCE_PROBABILITY)
						{
							value = ts.getDataValue(date);
							if (!ts.isDataMissing(value))
							{
								newts.setDataValue(date,MathUtil.nonexceedanceProbability(count, sampleArray, value) * unitsMult);
							}
						}
						else if (statisticType == TSStatisticType.PLOTTING_POSITION)
						{
							value = ts.getDataValue(date);
							if (!ts.isDataMissing(value))
							{
								// The value will also be in the array so it should exactly match a rank.
								// The following algorithm will lookup the value.
								newts.setDataValue(date,MathUtil.plottingPosition(count, sampleArray, sortOrderType, distributionType, distributionParameters, value));
							}
						}
						else if (statisticType == TSStatisticType.RANK)
						{
							value = ts.getDataValue(date);
							if (!ts.isDataMissing(value))
							{
								// The value will also be in the array so it should exactly match a rank.
								// The following algorithm will lookup the value.
								newts.setDataValue(date,MathUtil.rank(count, sampleArray, sortOrderType, value));
							}
						}
						else if (statisticType == TSStatisticType.SKEW)
						{
							newts.setDataValue(date,MathUtil.skew(count, sampleArray));
						}
						else if (statisticType == TSStatisticType.STD_DEV)
						{
							newts.setDataValue(date,MathUtil.standardDeviation(count, sampleArray));
						}
						else if (statisticType == TSStatisticType.TOTAL)
						{
							newts.setDataValue(date,MathUtil.sum(count, sampleArray));
						}
						else if (statisticType == TSStatisticType.VARIANCE)
						{
							newts.setDataValue(date,MathUtil.variance(count, sampleArray));
						}
					}
					catch (Exception e)
					{
						// Should only happen in cases where there is a data issue (insufficient data in sample should
						// just result in missing values)...
						__problems.Add("Error computing statistic at " + date + " (" + e + ")");
					}
				}
			}
			if (statisticTypeForNormal != null)
			{
				// Handle cases where a secondary statistic is being computed
				// Have to process the original value (ts) and the intermediate statistic (newts)
				// to get the final output (newts2)
				// Complexity for normal period - the initial analysis is performed on the normal period but the analysis
				// period may not exactly align.  Because the normal period can only be specified
				// with bracket of ALL_YEARS, can go through the initial statistic time series and find a value
				// on the same date to use for the math - this is all handled below
				// FIXME SAM - remove this when figured out issues..
				//for ( DateTime d = new DateTime(newts.getDate1()); d.lessThanOrEqualTo(newts.getDate2()); d.addInterval(intervalBase,intervalMult) ) {
				//	Message.printStatus(2, routine, "After computing normal period statistic, date=" + d + " value=" + newts.getDataValue(d));
				//}
				date = new DateTime(analysisStart);
				end = new DateTime(analysisEnd);
				DateTime normalStart2 = null;
				DateTime normalEnd2 = null;
				if (normalStart != null)
				{
					normalStart2 = new DateTime(normalStart);
				}
				else
				{
					normalStart2 = new DateTime(analysisStart);
				}
				if (normalEnd != null)
				{
					normalEnd2 = new DateTime(normalEnd);
				}
				else
				{
					normalEnd2 = new DateTime(analysisEnd);
				}
				DateTime normalDate = new DateTime(normalStart); // To get proper precision
				double normalValue; // The value computed as the normal
				for (; date.lessThanOrEqualTo(end); date.addInterval(intervalBase, intervalMult))
				{
					value = ts.getDataValue(date);
					// Set the normal date to match the date but make sure the year is in the normal period
					// If normal period is specified, then only AllYears for sample is allowed so all values
					// that were computed in newts in the analysis period will be the same on the interval of interest
					// (e.g., Jan 1).
					setNormalDateForAnalysisDate(normalDate,date,normalStart2,normalEnd2);
					normalValue = newts.getDataValue(normalDate);
					if (ts.isDataMissing(value))
					{
						// Can't compute the secondary statistic so set missing
						newts2.setDataValue(date,missing,"tsmissing",-1);
						continue;
					}
					else if (newts.isDataMissing(normalValue))
					{
						// Can't compute the secondary statistic so set missing
						newts2.setDataValue(date,missing,"stat0missing",-1);
						continue;
					}
					else if ((statisticTypeForNormal == TSStatisticType.PERCENT_OF_MEAN) || (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MEDIAN) || (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MAX) || (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MIN))
					{
						if (normalValue == 0.0)
						{
							// Division by zero so set to missing and set data flag
							newts2.setDataValue(date,missing,"input zero",-1);
						}
						else
						{
							newts2.setDataValue(date,(value / normalValue) * 100.0);
						}
					}
					else
					{
						throw new Exception("Unable to handle statistic for normal period:  " + statisticTypeForNormal);
					}
				}
				// Reset the output time series
				newts = newts2;
			}
			/* TODO SAM 2014-03-20 Remove this when tested out.
			if ( statisticTypeForNormal != null ) {
			    // Handle cases where a secondary statistic is being computed
			    // If the analysis period is the same as the normal period then just divide the original value by
			    // the calculated statistic.  If the periods are different need to allocate a new time series (was already
			    // done above as newts2).
			    if ( ((normalStart == null) && (normalEnd == null)) ||
			        ((normalStart.equals(analysisStart) && normalEnd.equals(analysisEnd)) ) ) {
			        date = new DateTime(analysisStart);
			        end = new DateTime(analysisEnd);
			        for ( ; date.lessThanOrEqualTo( end ); date.addInterval(intervalBase, intervalMult) ) {
			            value = ts.getDataValue(date);
			            if ( ts.isDataMissing(value) ) {
			                // Can't compute the secondary statistic so set missing
			                newts.setDataValue(date,missing);
			                continue;
			            }
			            if ( (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MEAN) ||
			                (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MEDIAN) ||
			                (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MAX) ||
			                (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MIN) ) {
			                if ( newts.getDataValue(date) == 0.0 ) {
			                    // Division by zero so set to missing
			                    newts.setDataValue(date,missing);
			                }
			                else {
			                    newts.setDataValue(date,(value/newts.getDataValue(date))*100.0);
			                }
			            }
			        }
			    }
			    else if ( ((normalStart != null) && (normalEnd != null)) &&
			        ((!normalStart.equals(analysisStart) && (!normalEnd.equals(analysisEnd))) ) ) {
			        // Need to create a new output time series because the first pass is not the final output
			        date = new DateTime(analysisStart);
			        end = new DateTime(analysisEnd);
			        DateTime normalDate = new DateTime(normalStart); // To get proper precision
			        double normalValue; // The value computed as the normal
			        for ( ; date.lessThanOrEqualTo( end ); date.addInterval(intervalBase, intervalMult) ) {
			            value = ts.getDataValue(date);
			            // Set the normal date to match the date but make sure the year is in the normal period
			            // If normal period is specified, then only AllYears for sample is allowed so all values
			            // that were computed in newts in the analysis period will be the same on the interval of interest
			            // (e.g., Jan 1).
			            setNormalDateForAnalysisDate(normalDate,date,normalStart,normalEnd);
			            normalValue = newts.getDataValue(normalDate);
			            if ( ts.isDataMissing(value) ) {
			                // Can't compute the secondary statistic so set missing
			                newts2.setDataValue(date,missing,"tsmissing",-1);
			                continue;
			            }
			            else if ( newts.isDataMissing(normalValue)) {
			                // Can't compute the secondary statistic so set missing
			                newts2.setDataValue(date,missing,"stat0missing",-1);
			                continue;
			            }
			            else if ( (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MEAN) ||
			                (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MEDIAN) ||
			                (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MAX) ||
			                (statisticTypeForNormal == TSStatisticType.PERCENT_OF_MIN) ) {
			                if ( normalValue == 0.0 ) {
			                    // Division by zero so set to missing and set data flag
			                    newts2.setDataValue(date,missing,"input zero",-1);
			                }
			                else {
			                    newts2.setDataValue(date,(value/normalValue)*100.0);
			                }
			            }
			            else {
			                throw new RuntimeException ( "Unable to handle statistic for normal period:  " + statisticTypeForNormal );
			            }
			        }
			        // Reset the output time series
			        newts = newts2;
			    }
			}
			*/

			// Add to the genesis...

			newts.addToGenesis("Created " + genesis + " running " + statString + " time series from original data");
			newts.setDescription(newts.getDescription() + ", " + genesis + " run stat");
		}
		return newts;
	}

	/// <summary>
	/// Set the number of missing values allowed in the sample.
	/// </summary>
	private void setAllowMissingCount(int allowMissingCount)
	{
		__allowMissingCount = allowMissingCount;
	}

	/// <summary>
	/// Set the analysis period end.
	/// </summary>
	private void setAnalysisEnd(DateTime analysisEnd)
	{
		__analysisEnd = analysisEnd;
	}

	/// <summary>
	/// Set the analysis period start.
	/// </summary>
	private void setAnalysisStart(DateTime analysisStart)
	{
		__analysisStart = analysisStart;
	}

	/// <summary>
	/// Set the distribution type.
	/// </summary>
	private void setDistributionType(DistributionType distribution)
	{
		__distribution = distribution;
	}

	/// <summary>
	/// Set the distribution parameters.
	/// </summary>
	private void setDistributionParameters(Dictionary<string, string> distributionParameters)
	{
		__distributionParameters = distributionParameters;
	}

	/// <summary>
	/// Set the minimum sample size in order to calculate the statistic.
	/// </summary>
	private void setMinimumSampleSize(int minimumSampleSize)
	{
		__minimumSampleSize = minimumSampleSize;
	}

	/// <summary>
	/// Set the N for N-Year or bracket for other running statistic types.
	/// </summary>
	private void setN(int n)
	{
		__n = n;
	}

	/// <summary>
	/// Set the monthly N for N-Year or bracket for other running statistic types.
	/// </summary>
	private void setNByMonth(int?[] nByMonth)
	{
		__nByMonth = nByMonth;
	}

	/// <summary>
	/// Set the custom monthly N for N-Year or bracket for other running statistic types.
	/// </summary>
	private void setNCustomByMonth(int?[][] nCustomByMonth)
	{
		__nCustomByMonth = nCustomByMonth;
	}

	/// <summary>
	/// Set the date in the normal period for an analysis date.  The normal date must be consistent with the analysis date,
	/// with everything the same and the year being aligned so that leap year (or not) overlay.  This ensures that the
	/// day from the normal period will be correct when requested for the analysis date.  This method is called when
	/// computing final output using the normal period statistics. </summary>
	/// <param name="normalDate"> the date from the normal period to be adjusted </param>
	/// <param name="analysisDate"> the date from the analysis period from iteration
	/// @normalStart the start of the normal period
	/// @normalEnd the end of the normal period </param>
	private void setNormalDateForAnalysisDate(DateTime normalDate, DateTime analysisDate, DateTime normalStart, DateTime normalEnd)
	{ // Calculate how many years AFTER a leap year the analysisDate is
		int ay = analysisDate.getYear();
		bool isLeap = TimeUtil.isLeapYear(ay);
		// First set the date to the current analysis date
		normalDate.setDate(analysisDate);
		normalDate.setYear(normalStart.getYear());
		if (normalDate.lessThan(normalStart))
		{
			// Need to go a year forward due to how the first month/day occur to be in the normal period
			normalDate.addYear(1);
		}
		if (isLeap)
		{
			// Move forward until within the normal period until a leap year is matched
			for (int i = 0; i < 4; i++)
			{
				if (TimeUtil.isLeapYear(normalDate.getYear()))
				{
					break;
				}
				normalDate.addYear(1);
			}
		}
		if (normalDate.greaterThan(normalEnd))
		{
			// This should not happen but check to make sure
			throw new Exception("Unable to determine date in normal period (" + normalStart + " - " + normalEnd + ") starting with analysis date " + analysisDate + " - normal period too short?");
		}
	}

	/// <summary>
	/// Set the normal period end.
	/// </summary>
	private void setNormalEnd(DateTime normalEnd)
	{
		__normalEnd = normalEnd;
	}

	/// <summary>
	/// Set the normal period start.
	/// </summary>
	private void setNormalStart(DateTime normalStart)
	{
		__normalStart = normalStart;
	}

	/// <summary>
	/// Set the output period end.
	/// </summary>
	private void setOutputEnd(DateTime outputEnd)
	{
		__outputEnd = outputEnd;
	}

	/// <summary>
	/// Set the output period start.
	/// </summary>
	private void setOutputStart(DateTime outputStart)
	{
		__outputStart = outputStart;
	}

	/// <summary>
	/// Set the units for probability statistics.
	/// </summary>
	private void setProbabilityUnits(string probabilityUnits)
	{
		__probabilityUnits = probabilityUnits;
	}

	/// <summary>
	/// Set the method by which the data sample is determined.
	/// </summary>
	private void setSampleType(RunningAverageType runningAverageType)
	{
		__SampleType = runningAverageType;
	}

	/// <summary>
	/// Set the sort order.
	/// </summary>
	private void setSortOrderType(SortOrderType sortOrderType)
	{
		__sortOrderType = sortOrderType;
	}

	/// <summary>
	/// Set the statistic.
	/// </summary>
	private void setStatisticType(TSStatisticType statistic)
	{
		__statistic = statistic;
	}

	/// <summary>
	/// Set the time series to process.
	/// </summary>
	private void setTS(TS ts)
	{
		__ts = ts;
	}

	}

}